<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FPS Maze — Sword & Monsters (module)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:sans-serif}
  #hud{position: absolute; left: 10px; top: 10px; color: white; z-index: 10}
  #info{position:absolute;top:10px;left:50%;transform:translateX(-50%);color:white;z-index:10}
  #healthBar{width:200px;height:18px;background:#333;border-radius:6px;overflow:hidden}
  #healthFill{height:100%;background:#c33;width:100%}
  canvas{display:block}
</style>
</head>
<body>
<div id="info">Click screen to lock mouse → Move: W A S D | Swing: Left Click</div>
<div id="hud">
  <div>Health</div>
  <div id="healthBar"><div id="healthFill"></div></div>
</div>

<script type="module">
/* Module imports (ES modules) */
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/PointerLockControls.js';

let camera, scene, renderer, controls;
const move = { forward:false, backward:false, left:false, right:false };
let yaw = 0, pitch = 0;
let velocity = new THREE.Vector3();
const monsters = [];
const walls = [];
let swordCooldown = 0;
let playerHealth = 100;

const HEALTH_FILL = document.getElementById('healthFill');

init();
animate();

function init(){
  // Scene & Camera
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 2, 10);

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(5, 10, 7);
  scene.add(dir);

  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(300, 300),
    new THREE.MeshPhongMaterial({ color: 0x8fbf8f })
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Build a simple blocky "maze" (grid)
  const wallGeo = new THREE.BoxGeometry(4, 4, 4);
  const wallMat = new THREE.MeshPhongMaterial({ color: 0x556b2f });
  // create outer border and some internal blocks
  for(let x=-48; x<=48; x+=4){
    for(let z=-48; z<=48; z+=4){
      // border
      if (x === -48 || x === 48 || z === -48 || z === 48) {
        const b = new THREE.Mesh(wallGeo, wallMat);
        b.position.set(x, 2, z);
        scene.add(b);
        walls.push(b);
      } else {
        // random obstacles to make a maze-like field
        if (Math.random() < 0.08) {
          const b = new THREE.Mesh(wallGeo, wallMat);
          b.position.set(x, 2, z);
          scene.add(b);
          walls.push(b);
        }
      }
    }
  }

  // Add a visible "spawn" platform / cube near start
  const startCube = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshPhongMaterial({color:0x4444ff}));
  startCube.position.set(0,1.5,0);
  scene.add(startCube);

  // Monsters: a handful of red cubes
  const mGeo = new THREE.BoxGeometry(2,2,2);
  const mMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
  for(let i=0;i<6;i++){
    const m = new THREE.Mesh(mGeo, mMat);
    // spawn away from player
    m.position.set((Math.random()*80)-40, 1, (Math.random()*80)-40);
    scene.add(m);
    monsters.push({ mesh: m, hp: 3, speed: 0.03 + Math.random()*0.05, attackCooldown: 0 });
  }

  // Sword object attached to camera (simple visual)
  const swordGeo = new THREE.BoxGeometry(0.15, 1.25, 0.15);
  const swordMat = new THREE.MeshPhongMaterial({ color: 0xccaa33 });
  const sword = new THREE.Mesh(swordGeo, swordMat);
  sword.position.set(0.5, -0.7, -1.5);
  camera.add(sword);
  scene.add(camera); // camera added to scene so child is rendered

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // Pointer lock controls (this is the ES-module version)
  controls = new PointerLockControls(camera, document.body);
  document.addEventListener('click', () => {
    // left click triggers sword swing + pointer lock
    // lock first if not locked
    if (!controls.isLocked) controls.lock();
  });

  // Left click for swing
  window.addEventListener('pointerdown', (ev) => {
    // only left button
    if (ev.button === 0) {
      if (controls.isLocked && swordCooldown <= 0) {
        swordCooldown = 0.4; // seconds
        attemptSwordHit();
      }
    }
  });

  // Movement keys
  document.addEventListener('keydown', (e) => {
    switch(e.code){
      case 'KeyW': move.forward = true; break;
      case 'KeyS': move.backward = true; break;
      case 'KeyA': move.left = true; break;
      case 'KeyD': move.right = true; break;
    }
  });
  document.addEventListener('keyup', (e) => {
    switch(e.code){
      case 'KeyW': move.forward = false; break;
      case 'KeyS': move.backward = false; break;
      case 'KeyA': move.left = false; break;
      case 'KeyD': move.right = false; break;
    }
  });

  // Mouse look handled by PointerLockControls; keep yaw/pitch for movement
  controls.addEventListener('lock', () => {
    document.getElementById('info').style.display = 'none';
  });
  controls.addEventListener('unlock', () => {
    document.getElementById('info').style.display = '';
  });

  window.addEventListener('resize', onWindowResize);
}

function attemptSwordHit(){
  // raycast from camera forward a short distance to detect monsters
  const raycaster = new THREE.Raycaster();
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
  raycaster.set(camera.position, dir);
  const hits = raycaster.intersectObjects(monsters.map(m=>m.mesh), true);
  if(hits.length){
    const first = hits[0];
    // if within range (2.5 units)
    if (first.distance < 3.0) {
      // find monster object
      const mobj = monsters.find(m=>m.mesh === first.object);
      if (mobj) {
        mobj.hp -= 1;
        // small visual reaction: scale down briefly
        mobj.mesh.scale.set(0.9,0.9,0.9);
        setTimeout(()=> mobj.mesh.scale.set(1,1,1), 120);
        if (mobj.hp <= 0) {
          // remove from scene and array
          scene.remove(mobj.mesh);
          const idx = monsters.indexOf(mobj);
          if (idx !== -1) monsters.splice(idx,1);
        }
      }
    }
  }
}

function onWindowResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

let lastTime = performance.now();
function animate(now = performance.now()){
  requestAnimationFrame(animate);
  const dt = (now - lastTime) / 1000; // seconds
  lastTime = now;

  // update sword cooldown
  if (swordCooldown > 0) swordCooldown = Math.max(0, swordCooldown - dt);

  // movement when pointer is locked
  if (controls.isLocked){
    // movement velocity damping
    velocity.x -= velocity.x * 10.0 * dt;
    velocity.z -= velocity.z * 10.0 * dt;

    // get current forward/right vectors from camera yaw
    const quat = camera.quaternion;
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).setY(0).normalize();
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat).setY(0).normalize();

    const moveVec = new THREE.Vector3();
    if (move.forward) moveVec.add(forward);
    if (move.backward) moveVec.sub(forward);
    if (move.left) moveVec.sub(right);
    if (move.right) moveVec.add(right);
    moveVec.normalize();

    const speed = 5.0; // units per second
    camera.position.addScaledVector(moveVec, speed * dt);

    // simple collision with walls: if camera inside a wall bounding box, push out
    for (const w of walls){
      const dx = camera.position.x - w.position.x;
      const dz = camera.position.z - w.position.z;
      const overlap = 2.0; // approximate radius
      if (Math.abs(dx) < 2 + overlap && Math.abs(dz) < 2 + overlap){
        // push camera out along larger axis
        if (Math.abs(dx) > Math.abs(dz)) {
          camera.position.x += (dx > 0 ? 1 : -1) * 0.15;
        } else {
          camera.position.z += (dz > 0 ? 1 : -1) * 0.15;
        }
      }
    }

    // monsters AI: move toward player, attack on touch
    for (const m of monsters){
      const dir = new THREE.Vector3().subVectors(camera.position, m.mesh.position);
      dir.y = 0;
      const dist = dir.length();
      if (dist > 0.001){
        dir.normalize();
        m.mesh.position.addScaledVector(dir, m.speed);
      }
      // if too close, damage player with cooldown
      if (dist < 2.2){
        if (m.attackCooldown <= 0){
          playerHealth -= 10;
          m.attackCooldown = 1.0; // 1 second between attacks
          updateHealthHud();
          // flash monster or give reaction
          m.mesh.material.color.setHex(0xffaa88);
          setTimeout(()=> m.mesh.material.color.setHex(0xff4444), 150);
        }
      }
      // decrease attack cooldown
      m.attackCooldown = Math.max(0, m.attackCooldown - dt);
    }

    // If player health reaches zero, show message and reset
    if (playerHealth <= 0){
      alert('You died — refreshing the level.');
      window.location.reload();
      return;
    }
  }

  renderer.render(scene, camera);
}

function updateHealthHud(){
  const pct = Math.max(0, Math.min(100, playerHealth));
  HEALTH_FILL.style.width = pct + '%';
  if (pct > 60) HEALTH_FILL.style.background = '#3c9';
  else if (pct > 30) HEALTH_FILL.style.background = '#fc3';
  else HEALTH_FILL.style.background = '#c33';
}

// initial HUD update
updateHealthHud();

</script>
</body>
</html>
