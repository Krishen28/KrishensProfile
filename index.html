<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STONE LABYRINTH - Portable</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'neon-cyan': '#00ffff',
                        'neon-pink': '#ff00ff',
                        'neon-purple': '#a855f7',
                    },
                    fontFamily: {
                        'press': ['"Press Start 2P"', 'system-ui'],
                        'mono': ['"Space Mono"', 'monospace'],
                    },
                    animation: {
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite',
                    },
                    keyframes: {
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0) rotate(-1deg)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0) rotate(2deg)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0) rotate(-4deg)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0) rotate(4deg)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #050510;
            color: #e0f7fa;
            background-image: radial-gradient(circle at center, hsla(270, 50%, 10%, 0.5) 0%, transparent 100%);
            margin: 0;
            overflow: hidden;
        }
        .text-glow { text-shadow: 0 0 10px currentColor; }
        .text-glow-white { text-shadow: 0 0 15px rgba(255, 255, 255, 0.8); }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;
        const { motion, AnimatePresence } = window.Motion;
        // --- ICONS ---
        const Icon = ({ name, size = 24, className, ...props }) => {
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                    {iconData.map((child, index) => {
                        const [tag, attrs] = child;
                        return React.createElement(tag, { ...attrs, key: index });
                    })}
                </svg>
            );
        };
        const Zap = (p) => <Icon name="Zap" {...p} />;
        const Clock = (p) => <Icon name="Clock" {...p} />;
        const Eye = (p) => <Icon name="Eye" {...p} />;
        const Ghost = (p) => <Icon name="Ghost" {...p} />;
        const Box = (p) => <Icon name="Box" {...p} />;
        const Triangle = (p) => <Icon name="Triangle" {...p} />;
        const Circle = (p) => <Icon name="Circle" {...p} />;
        const Sword = (p) => <Icon name="Sword" {...p} />;
        const Star = (p) => <Icon name="Star" {...p} />;
        const Crown = (p) => <Icon name="Crown" {...p} />;
        const Snowflake = (p) => <Icon name="Snowflake" {...p} />;
        const Footprints = (p) => <Icon name="Footprints" {...p} />;
        const Gem = (p) => <Icon name="Gem" {...p} />;
        const Heart = (p) => <Icon name="Heart" {...p} />;
        const Moon = (p) => <Icon name="Moon" {...p} />;
        const Sun = (p) => <Icon name="Sun" {...p} />;
        const Flame = (p) => <Icon name="Flame" {...p} />;
        const Skull = (p) => <Icon name="Skull" {...p} />;
        const Trophy = (p) => <Icon name="Trophy" {...p} />;
        const Timer = (p) => <Icon name="Timer" {...p} />;
        const RefreshCw = (p) => <Icon name="RefreshCw" {...p} />;
        const ArrowLeft = (p) => <Icon name="ArrowLeft" {...p} />;
        const Lock = (p) => <Icon name="Lock" {...p} />;
        const Unlock = (p) => <Icon name="Unlock" {...p} />;
        const ShieldAlert = (p) => <Icon name="ShieldAlert" {...p} />;
        const Palette = (p) => <Icon name="Palette" {...p} />;
        const SkipForward = (p) => <Icon name="SkipForward" {...p} />;
        const Package = (p) => <Icon name="Package" {...p} />;
        const ShoppingCart = (p) => <Icon name="ShoppingCart" {...p} />;
        const Coins = (p) => <Icon name="Coins" {...p} />;
        const X = (p) => <Icon name="X" {...p} />;
        const Ticket = (p) => <Icon name="Ticket" {...p} />;
        // --- UI COMPONENTS ---
        const Button = ({ children, className, variant = "default", size = "default", ...props }) => {
            const baseStyles = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50";
            const variants = {
                default: "bg-white text-black hover:bg-gray-200",
                destructive: "bg-red-900 text-white hover:bg-red-800",
                outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
                secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
                ghost: "hover:bg-accent hover:text-accent-foreground",
            };
            const sizes = { default: "h-9 px-4 py-2", sm: "h-8 rounded-md px-3 text-xs", lg: "h-10 rounded-md px-8", icon: "h-9 w-9" };
            return <button className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`} {...props}>{children}</button>;
        };
        const Card = ({ className, ...props }) => <div className={`rounded-xl border bg-card text-card-foreground shadow ${className}`} {...props} />;
        const Input = ({ className, ...props }) => <input className={`flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 ${className}`} {...props} />;
        const Switch = ({ checked, onCheckedChange, className }) => (
            <button role="switch" aria-checked={checked} onClick={() => onCheckedChange(!checked)} className={`peer inline-flex h-[20px] w-[36px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 ${checked ? 'bg-green-500' : 'bg-gray-700'} ${className}`}>
                <span className={`pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform ${checked ? 'translate-x-4 bg-white' : 'translate-x-0 bg-white'}`} />
            </button>
        );
        // Fixed Modal Component - Decoupled from Trigger
        const Modal = ({ open, onClose, children, className }) => {
            if (!open) return null;
            return (
                <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
                    <div className={`relative w-full max-w-lg animate-in zoom-in-95 duration-200 bg-black border border-gray-700 p-6 shadow-lg sm:rounded-lg ${className}`} onClick={(e) => e.stopPropagation()}>
                        {children}
                        <button onClick={onClose} className="absolute right-4 top-4 opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none disabled:pointer-events-none text-white">
                            <X size={16} /><span className="sr-only">Close</span>
                        </button>
                    </div>
                    <div className="absolute inset-0 -z-10" onClick={onClose}></div>
                </div>
            );
        };
        const ModalHeader = ({ className, ...props }) => <div className={`flex flex-col space-y-1.5 text-center sm:text-left mb-4 ${className}`} {...props} />;
        const ModalTitle = ({ className, ...props }) => <h2 className={`text-lg font-semibold leading-none tracking-tight ${className}`} {...props} />;
        const ModalDescription = ({ className, ...props }) => <p className={`text-sm text-muted-foreground mt-2 ${className}`} {...props} />;
        // Toast System
        const ToastContext = React.createContext({});
        const useToast = () => React.useContext(ToastContext);
        const Toaster = () => {
            const { toasts } = useToast();
            return (
                <div className="fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]">
                    {toasts.map(t => (
                        <div key={t.id} className={`group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all ${t.className || 'bg-background text-foreground'}`}>
                            <div className="grid gap-1">
                                {t.title && <div className="text-sm font-semibold">{t.title}</div>}
                                {t.description && <div className="text-sm opacity-90">{t.description}</div>}
                            </div>
                        </div>
                    ))}
                </div>
            );
        };
        // --- MAZE LOGIC ---
        function generateMaze(width, height) {
            const grid = [];
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) { row.push({ x, y, top: true, right: true, bottom: true, left: true, visited: false }); }
                grid.push(row);
            }
            const stack = [];
            const start = grid[0][0];
            start.visited = true;
            stack.push(start);
            function getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const { x, y } = cell;
                if (y > 0 && !grid[y - 1][x].visited) neighbors.push(grid[y - 1][x]);
                if (x < width - 1 && !grid[y][x + 1].visited) neighbors.push(grid[y][x + 1]);
                if (y < height - 1 && !grid[y + 1][x].visited) neighbors.push(grid[y + 1][x]);
                if (x > 0 && !grid[y][x - 1].visited) neighbors.push(grid[y][x - 1]);
                return neighbors;
            }
            function removeWalls(a, b) {
                const xDiff = a.x - b.x;
                const yDiff = a.y - b.y;
                if (xDiff === 1) { a.left = false; b.right = false; } else if (xDiff === -1) { a.right = false; b.left = false; }
                if (yDiff === 1) { a.top = false; b.bottom = false; } else if (yDiff === -1) { a.bottom = false; b.top = false; }
            }
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current);
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    removeWalls(current, next);
                    next.visited = true;
                    stack.push(next);
                } else { stack.pop(); }
            }
            const itemCount = Math.max(1, Math.floor((width * height) / 40));
            for (let i = 0; i < itemCount; i++) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 100) {
                    const x = Math.floor(Math.random() * width);
                    const y = Math.floor(Math.random() * height);
                    if ((x === 0 && y === 0) || (x === width - 1 && y === height - 1)) continue;
                    if (grid[y][x].item) continue;
                    const rand = Math.random();
                    if (rand < 0.25) grid[y][x].item = 'speed';
                    else if (rand < 0.5) grid[y][x].item = 'time';
                    else if (rand < 0.7) grid[y][x].item = 'vision';
                    else if (rand < 0.85) grid[y][x].item = 'ghost';
                    else grid[y][x].item = 'freeze';
                    placed = true;
                    attempts++;
                }
            }
            return grid;
        }
        function solveMaze(grid, start, end) {
            const queue = [];
            const visited = new Set();
            queue.push({ ...start, path: [start] });
            visited.add(`${start.x},${start.y}`);
            while (queue.length > 0) {
                const { x, y, path } = queue.shift();
                if (x === end.x && y === end.y) return path;
                const current = grid[y][x];
                const neighbors = [];
                if (!current.top && y > 0) neighbors.push({ x, y: y - 1 });
                if (!current.bottom && y < grid.length - 1) neighbors.push({ x, y: y + 1 });
                if (!current.left && x > 0) neighbors.push({ x: x - 1, y });
                if (!current.right && x < grid[0].length - 1) neighbors.push({ x: x + 1, y });
                for (const n of neighbors) {
                    const key = `${n.x},${n.y}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: n.x, y: n.y, path: [...path, n] });
                    }
                }
            }
            return [];
        }
        const SKIN_RARITIES = {
            'orb': 'Common', 'cube': 'Common', 'triangle': 'Common',
            'diamond': 'Uncommon', 'heart': 'Uncommon',
            'star': 'Rare', 'moon': 'Rare',
            'lightning': 'Epic', 'sun': 'Epic',
            'crown': 'Legendary', 'skull': 'Legendary',
            'ghost': 'Mythic', 'flame': 'Mythic',
            'slayer': 'Special', 'ninja': 'Special', 'master': 'Special'
        };
        function MazeRenderer({ maze, cellSize, playerPos, solutionPath, isSpeedActive, skin = 'orb' }) {
            const width = maze[0].length * cellSize;
            const height = maze.length * cellSize;
            const paths = useMemo(() => {
                const wallPaths = [];
                maze.forEach((row) => {
                    row.forEach((cell) => {
                        const x = cell.x * cellSize;
                        const y = cell.y * cellSize;
                        if (cell.top) wallPaths.push(`M${x},${y} L${x + cellSize},${y}`);
                        if (cell.left) wallPaths.push(`M${x},${y} L${x},${y + cellSize}`);
                        if (cell.right && cell.x === maze[0].length - 1) wallPaths.push(`M${x + cellSize},${y} L${x + cellSize},${y + cellSize}`);
                        if (cell.bottom && cell.y === maze.length - 1) wallPaths.push(`M${x},${y + cellSize} L${x + cellSize},${y + cellSize}`);
                    });
                });
                return wallPaths.join(" ");
            }, [maze, cellSize]);
            const solutionPathD = useMemo(() => {
                if (!solutionPath || solutionPath.length === 0) return "";
                return solutionPath.map((p, i) => {
                    const x = p.x * cellSize + cellSize / 2;
                    const y = p.y * cellSize + cellSize / 2;
                    return `${i === 0 ? 'M' : 'L'}${x},${y}`;
                }).join(" ");
            }, [solutionPath, cellSize]);
            const renderPlayerSkin = () => {
                const commonProps = { className: "text-neon-pink drop-shadow-[0_0_8px_rgba(236,72,153,0.8)]", size: cellSize * 0.7, strokeWidth: 2.5 };
                switch (skin) {
                    case 'cube': return <Box {...commonProps} className="text-neon-cyan drop-shadow-[0_0_8px_rgba(34,211,238,0.8)]" />;
                    case 'triangle': return <Triangle {...commonProps} className="text-yellow-400 drop-shadow-[0_0_8px_rgba(250,204,21,0.8)]" />;
                    case 'diamond': return <Gem {...commonProps} className="text-blue-400 drop-shadow-[0_0_8px_rgba(96,165,250,0.8)]" />;
                    case 'heart': return <Heart {...commonProps} className="text-red-400 drop-shadow-[0_0_8px_rgba(248,113,113,0.8)]" />;
                    case 'star': return <Star {...commonProps} className="text-purple-400 drop-shadow-[0_0_8px_rgba(192,132,252,0.8)]" />;
                    case 'moon': return <Moon {...commonProps} className="text-indigo-300 drop-shadow-[0_0_8px_rgba(165,180,252,0.8)]" />;
                    case 'lightning': return <Zap {...commonProps} className="text-yellow-300 drop-shadow-[0_0_8px_rgba(253,224,71,0.8)]" />;
                    case 'sun': return <Sun {...commonProps} className="text-orange-400 drop-shadow-[0_0_8px_rgba(251,146,60,0.8)]" />;
                    case 'crown': return <Crown {...commonProps} className="text-yellow-500 drop-shadow-[0_0_8px_rgba(234,179,8,0.8)]" />;
                    case 'skull': return <Skull {...commonProps} className="text-gray-200 drop-shadow-[0_0_8px_rgba(229,231,235,0.8)]" />;
                    case 'ghost': return <Ghost {...commonProps} className="text-white drop-shadow-[0_0_8px_rgba(255,255,255,0.8)] opacity-80" />;
                    case 'flame': return <Flame {...commonProps} className="text-red-500 drop-shadow-[0_0_8px_rgba(239,68,68,0.8)] animate-pulse" />;
                    case 'slayer': return <Sword {...commonProps} className="text-red-600 drop-shadow-[0_0_8px_rgba(220,38,38,0.8)]" />;
                    case 'ninja': return <Star {...commonProps} className="text-purple-600 drop-shadow-[0_0_8px_rgba(147,51,234,0.8)]" />;
                    case 'master': return <Crown {...commonProps} className="text-amber-500 drop-shadow-[0_0_8px_rgba(245,158,11,0.8)]" />;
                    default: return <Circle {...commonProps} fill="currentColor" className="text-neon-pink drop-shadow-[0_0_8px_rgba(236,72,153,0.8)]" />;
                }
            };
            return (
                <div className={`relative rounded-lg border-2 transition-colors duration-300 ${isSpeedActive ? 'border-blue-400 shadow-[0_0_30px_rgba(59,130,246,0.5)]' : 'border-neon-cyan shadow-[0_0_20px_rgba(0,255,255,0.3)]'} bg-black/50 p-4 backdrop-blur-sm`}>
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} className="overflow-visible">
                        <defs><filter id="glow" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur stdDeviation="2" result="blur" /><feComposite in="SourceGraphic" in2="blur" operator="over" /></filter></defs>
                        <AnimatePresence>
                            {solutionPathD && <motion.path initial={{ pathLength: 0, opacity: 0 }} animate={{ pathLength: 1, opacity: 1 }} exit={{ opacity: 0 }} d={solutionPathD} stroke="hsl(142, 70%, 50%)" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round" filter="url(#glow)" className="pointer-events-none" />}
                        </AnimatePresence>
                        <path d={paths} stroke="hsl(180, 100%, 50%)" strokeWidth="2" fill="none" strokeLinecap="round" filter="url(#glow)" className="opacity-80" />
                        {maze.map((row, y) => row.map((cell, x) => {
                            if (!cell.item) return null;
                            const cx = x * cellSize + cellSize / 2;
                            const cy = y * cellSize + cellSize / 2;
                            const size = cellSize * 0.6;
                            return (
                                <g key={`item-${x}-${y}`} transform={`translate(${cx - size/2}, ${cy - size/2})`}>
                                    {cell.item === 'speed' && <Zap size={size} className="text-blue-400 animate-pulse" strokeWidth={3} />}
                                    {cell.item === 'time' && <Clock size={size} className="text-yellow-400 animate-bounce" strokeWidth={3} />}
                                    {cell.item === 'vision' && <Eye size={size} className="text-green-400 animate-pulse" strokeWidth={3} />}
                                    {cell.item === 'ghost' && <Footprints size={size} className="text-purple-400 animate-pulse" strokeWidth={3} />}
                                    {cell.item === 'freeze' && <Snowflake size={size} className="text-cyan-200 animate-spin-slow" strokeWidth={3} />}
                                </g>
                            );
                        }))}
                        <rect x={(maze[0].length - 1) * cellSize + 4} y={(maze.length - 1) * cellSize + 4} width={cellSize - 8} height={cellSize - 8} fill="hsl(270, 100%, 60%)" className="animate-pulse" filter="url(#glow)" />
                        <motion.g initial={false} animate={{ x: playerPos.x * cellSize + cellSize / 2 - (cellSize * 0.7) / 2, y: playerPos.y * cellSize + cellSize / 2 - (cellSize * 0.7) / 2 }} transition={{ type: "spring", stiffness: isSpeedActive ? 1500 : 500, damping: isSpeedActive ? 15 : 30, mass: isSpeedActive ? 0.5 : 1 }}>
                            {renderPlayerSkin()}
                        </motion.g>
                    </svg>
                </div>
            );
        }
        const CELL_SIZE = 25;
        const INITIAL_TIME = 30;
        const ADMIN_CODE = "sussybaka120956";
        function Game() {
            const { toast } = useToast();
            const [level, setLevel] = useState(1);
            const [maze, setMaze] = useState([]);
            const [playerPos, setPlayerPos] = useState({ x: 0, y: 0 });
            const [timeLeft, setTimeLeft] = useState(INITIAL_TIME);
            const [gameState, setGameState] = useState("playing");
            const [solutionPath, setSolutionPath] = useState(undefined);
            const [isSpeedActive, setIsSpeedActive] = useState(false);
            const [isGhostActive, setIsGhostActive] = useState(false);
            const [isTimeFrozenPowerup, setIsTimeFrozenPowerup] = useState(false);
            const [activeSkin, setActiveSkin] = useState('orb');
            const [unlockedSkins, setUnlockedSkins] = useState(['orb']); 
            const [packsAvailable, setPacksAvailable] = useState(0);
            const [isOpeningPack, setIsOpeningPack] = useState(false);
            const [openingStage, setOpeningStage] = useState('ready');
            const [packResult, setPackResult] = useState(null);
            const [coins, setCoins] = useState(0);
            const [isShopOpen, setIsShopOpen] = useState(false);
            const [isAdminOpen, setIsAdminOpen] = useState(false);
            const [isSkinsOpen, setIsSkinsOpen] = useState(false);
            const [adminPassword, setAdminPassword] = useState("");
            const [isAdminAuthenticated, setIsAdminAuthenticated] = useState(false);
            const [isTimeFrozen, setIsTimeFrozen] = useState(false);
            const [isVisionUnlimited, setIsVisionUnlimited] = useState(false);
            const [showCutscene, setShowCutscene] = useState(false);
            const [storyState, setStoryState] = useState('intro');
            const [storyStep, setStoryStep] = useState(0);
            const introDialog = [ "Welcome, little dot...", "I am the ARCHITECT of the STONE LABYRINTH.", "You seem lost. Good.", "Escape is impossible, but you are welcome to try.", "Survive my trials, and perhaps I will let you leave...", "BEGIN!" ];
            const level25Dialog = [ "IMPRESSIVE...", "You actually survived this long?", "But your luck ends HERE.", "I'm done playing fair.", "Let's see how you handle... TRUE CHAOS!", "DIE!" ];
            const victoryDialog = [ "NO...", "IMPOSSIBLE!", "My masterpiece... RUINED!", "You have bested me, anomaly.", "The labyrinth is yours.", "Begone." ];
            const currentDialog = storyState === 'intro' ? introDialog : storyState === 'level25_intro' ? level25Dialog : victoryDialog;
            const advanceStory = () => {
                if (storyStep < currentDialog.length - 1) { setStoryStep(s => s + 1); }
                else {
                    setStoryState('none'); setStoryStep(0);
                    if (storyState === 'intro') setGameState("playing");
                    else if (storyState === 'level25_intro') setGameState("playing");
                    else if (storyState === 'victory') setGameState("won");
                }
            };
            // --- VISION FIX: Recalculate path when Admin Vision is ON ---
            useEffect(() => {
                if (isVisionUnlimited && maze.length > 0) {
                    const path = solveMaze(maze, playerPos, {x: maze[0].length-1, y: maze.length-1});
                    setSolutionPath(path);
                } else if (!isVisionUnlimited) {
                    setSolutionPath(undefined);
                }
            }, [isVisionUnlimited, playerPos, maze]);
            useEffect(() => {
                if (level === 25 && gameState === "playing" && storyState === 'none') {
                    const chaosInterval = setInterval(() => {
                        setMaze(prev => {
                            const newMaze = generateMaze(prev[0].length, prev.length);
                            const { x, y } = playerPos;
                            if (newMaze[y] && newMaze[y][x]) {
                                newMaze[y][x].top = false; newMaze[y][x].bottom = false;
                                newMaze[y][x].left = false; newMaze[y][x].right = false;
                                if (y > 0) newMaze[y-1][x].bottom = false; if (y < newMaze.length-1) newMaze[y+1][x].top = false;
                                if (x > 0) newMaze[y][x-1].right = false; if (x < newMaze[0].length-1) newMaze[y][x+1].left = false;
                            }
                            toast({ title: "REALITY SHIFT!", description: "The Architect is warping the maze!", className: "bg-red-950 border-red-500 text-red-100 animate-pulse" });
                            return newMaze;
                        });
                    }, 8000);
                    return () => clearInterval(chaosInterval);
                }
            }, [level, gameState, storyState, playerPos]);
            const initLevel = useCallback((lvl) => {
                const isBossLevel = lvl % 5 === 0;
                let width, height;
                if (isBossLevel) {
                    width = 30; height = 20;
                    if (lvl === 25) { setStoryState('level25_intro'); toast({ title: "⚠️ ANOMALY DETECTED ⚠️", description: "The Architect is intervening...", className: "bg-red-950 border-red-500 text-red-100 font-bold animate-bounce" }); }
                    else { toast({ title: "⚠️ BOSS LEVEL ⚠️", description: "Survive the massive labyrinth!", className: "bg-red-950 border-red-500 text-red-100 font-bold" }); }
                } else {
                    width = Math.min(10 + lvl * 2, 30); height = Math.min(10 + lvl * 2, 20);
                    if (lvl % 6 === 0 && lvl !== 25 && lvl > 1) {
                        const taunts = [ "Still alive? How tedious.", "I'm just warming up.", "You run like a scared mouse.", "This maze has no end, fool.", "Do you really think you can escape?", "My patience is wearing thin." ];
                        const randomTaunt = taunts[Math.floor(Math.random() * taunts.length)];
                        toast({ title: "ARCHITECT:", description: `"${randomTaunt}"`, className: "bg-gray-900 border-purple-500 text-purple-200 font-mono" });
                    }
                }
                setMaze(generateMaze(width, height)); setPlayerPos({ x: 0, y: 0 });
                let newTimeLimit;
                if (lvl <= 3) newTimeLimit = 50; else if (lvl <= 7) newTimeLimit = 60; else newTimeLimit = 110;
                setTimeLeft(newTimeLimit); setGameState("playing"); setSolutionPath(undefined);
                setIsSpeedActive(false); setIsGhostActive(false); setIsTimeFrozenPowerup(false);
                setIsTimeFrozen(false); setIsVisionUnlimited(false); setShowCutscene(false);
            }, []);
            useEffect(() => { initLevel(level); }, [level, initLevel]);
            useEffect(() => {
                if (gameState !== "playing") return;
                if (isTimeFrozen || isTimeFrozenPowerup || storyState !== 'none') return;
                const timer = setInterval(() => { setTimeLeft((t) => { if (t <= 1) { setGameState("lost"); return 0; } return t - 1; }); }, 1000);
                return () => clearInterval(timer);
            }, [gameState, isTimeFrozen, isTimeFrozenPowerup, storyState]);
            useEffect(() => {
                if (gameState !== "playing" || showCutscene) return;
                const handleKeyDown = (e) => {
                    if (document.activeElement?.tagName === "INPUT") return;
                    const { x, y } = playerPos;
                    const currentCell = maze[y][x];
                    let nextX = x, nextY = y;
                    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();
                    const canMove = (dir) => isGhostActive || !currentCell[dir];
                    if ((e.key === "ArrowUp" || e.key === "w") && canMove('top')) nextY--;
                    if ((e.key === "ArrowRight" || e.key === "d") && canMove('right')) nextX++;
                    if ((e.key === "ArrowDown" || e.key === "s") && canMove('bottom')) nextY++;
                    if ((e.key === "ArrowLeft" || e.key === "a") && canMove('left')) nextX--;
                    if (nextY < 0 || nextY >= maze.length || nextX < 0 || nextX >= maze[0].length) return;
                    if (nextX !== x || nextY !== y) {
                        setPlayerPos({ x: nextX, y: nextY });
                        const nextCell = maze[nextY][nextX];
                        if (nextCell.item) {
                            if (nextCell.item === 'time') { setTimeLeft(t => t + 5); toast({ title: "Time Extended!", description: "+5 Seconds added", className: "bg-yellow-900 border-yellow-500 text-yellow-100" }); }
                            else if (nextCell.item === 'speed') { setIsSpeedActive(true); setTimeout(() => setIsSpeedActive(false), 5000); toast({ title: "Speed Boost!", description: "Super fast movement!", className: "bg-blue-900 border-blue-500 text-blue-100" }); }
                            else if (nextCell.item === 'vision') { const path = solveMaze(maze, {x: nextX, y: nextY}, {x: maze[0].length-1, y: maze.length-1}); setSolutionPath(path); setTimeout(() => setSolutionPath(undefined), 2000); toast({ title: "Path Revealed!", description: "Showing optimal path", className: "bg-green-900 border-green-500 text-green-100" }); }
                            else if (nextCell.item === 'ghost') { setIsGhostActive(true); setTimeout(() => setIsGhostActive(false), 5000); toast({ title: "Ghost Mode!", description: "Walk through walls!", className: "bg-purple-900 border-purple-500 text-purple-100" }); }
                            else if (nextCell.item === 'freeze') { setIsTimeFrozenPowerup(true); setTimeout(() => setIsTimeFrozenPowerup(false), 10000); toast({ title: "Time Freeze!", description: "Timer stopped for 10s!", className: "bg-cyan-900 border-cyan-500 text-cyan-100" }); }
                            const newMaze = [...maze];
                            newMaze[nextY][nextX] = { ...nextCell, item: undefined };
                            setMaze(newMaze);
                        }
                        if (nextX === maze[0].length - 1 && nextY === maze.length - 1) {
                            if (level === 25) setStoryState('victory');
                            else { setShowCutscene(true); setTimeout(() => { setShowCutscene(false); setGameState("won"); }, 1000); }
                        }
                    }
                };
                window.addEventListener("keydown", handleKeyDown);
                return () => window.removeEventListener("keydown", handleKeyDown);
            }, [playerPos, maze, gameState, isSpeedActive]);
            const openPack = () => { if (packsAvailable <= 0 || isOpeningPack) return; setPacksAvailable(p => p - 1); setIsOpeningPack(true); setOpeningStage('ready'); setPackResult(null); };
            const revealPack = () => {
                if (openingStage !== 'ready') return;
                setOpeningStage('shaking');
                const rand = Math.random() * 100;
                let rarity = 'Common';
                if (rand < 0.5) rarity = 'Mythic'; else if (rand < 5.5) rarity = 'Legendary'; else if (rand < 15.5) rarity = 'Epic'; else if (rand < 30) rarity = 'Rare'; else if (rand < 50) rarity = 'Uncommon';
                const skinsByRarity = { 'Common': ['orb', 'cube', 'triangle'], 'Uncommon': ['diamond', 'heart'], 'Rare': ['star', 'moon'], 'Epic': ['lightning', 'sun'], 'Legendary': ['crown', 'skull'], 'Mythic': ['ghost', 'flame'] };
                const pool = skinsByRarity[rarity];
                const wonSkin = pool[Math.floor(Math.random() * pool.length)];
                setTimeout(() => {
                    setPackResult(wonSkin);
                    setOpeningStage('revealed');
                    if (!unlockedSkins.includes(wonSkin)) { setUnlockedSkins(prev => [...prev, wonSkin]); toast({ title: `UNLOCKED: ${wonSkin.toUpperCase()}`, description: `You found a ${rarity} skin!`, className: "bg-neon-purple border-neon-pink text-white font-bold" }); }
                    else { toast({ title: "DUPLICATE", description: `You already have the ${wonSkin} skin.`, className: "bg-gray-800 border-gray-600 text-gray-400" }); }
                }, 2500);
            };
            const closePack = () => { setIsOpeningPack(false); setPackResult(null); setOpeningStage('ready'); };
            const nextLevel = () => {
                setCoins(c => c + 10); toast({ title: "LEVEL COMPLETE", description: "+10 COINS", className: "bg-yellow-900 border-yellow-500 text-white font-bold" });
                const nextLvl = level + 1;
                // Fixed: Packs every 3 levels
                if (nextLvl % 3 === 0) { setPacksAvailable(p => p + 1); toast({ title: "LOOT PACK EARNED!", description: "You've earned a skin pack!", className: "bg-neon-cyan border-white text-black font-bold animate-bounce" }); }
                if (nextLvl === 5 && !unlockedSkins.includes('slayer')) { setUnlockedSkins(p => [...p, 'slayer']); toast({ title: "NEW SKIN!", description: "Boss Slayer acquired!", className: "bg-red-900 border-red-500 text-white font-bold" }); }
                if (nextLvl === 10 && !unlockedSkins.includes('ninja')) { setUnlockedSkins(p => [...p, 'ninja']); toast({ title: "NEW SKIN!", description: "Neon Ninja acquired!", className: "bg-purple-900 border-purple-500 text-white font-bold" }); }
                if (nextLvl === 20 && !unlockedSkins.includes('master')) { setUnlockedSkins(p => [...p, 'master']); toast({ title: "NEW SKIN!", description: "Grandmaster Crown acquired!", className: "bg-yellow-900 border-yellow-500 text-white font-bold" }); }
                setLevel(l => l + 1);
            };
            const buyPowerUp = (type, cost) => {
                if (coins < cost) { toast({ title: "INSUFFICIENT FUNDS", description: `Need ${cost} coins.`, variant: "destructive" }); return; }
                setCoins(c => c - cost); spawnPowerUp(type); toast({ title: "PURCHASE SUCCESSFUL", description: `${type.toUpperCase()} deployed!`, className: "bg-green-900 border-green-500 text-white" });
            };
            const buySkipLevel = () => {
                const cost = 150;
                if (coins < cost) { toast({ title: "INSUFFICIENT FUNDS", description: `Need ${cost} coins.`, variant: "destructive" }); return; }
                setCoins(c => c - cost); setIsShopOpen(false); nextLevel(); toast({ title: "LEVEL SKIPPED", description: "Moving to next sector...", className: "bg-neon-cyan border-white text-black font-bold" });
            };
            const restart = () => { setLevel(1); setCoins(0); initLevel(1); };
            const retry = () => { initLevel(level); };
            const handleAdminLogin = () => { if (adminPassword === ADMIN_CODE) { setIsAdminAuthenticated(true); toast({ title: "Access Granted", description: "Welcome Commander.", className: "bg-red-900 border-red-500 text-red-100" }); } else toast({ variant: "destructive", title: "Access Denied" }); };
            const spawnPowerUp = (type) => {
                if (!maze.length) return;
                const newMaze = [...maze];
                let placed = false, attempts = 0;
                while (!placed && attempts < 100) {
                    const x = Math.floor(Math.random() * maze[0].length);
                    const y = Math.floor(Math.random() * maze.length);
                    if (!newMaze[y][x].item && (x !== playerPos.x || y !== playerPos.y)) { newMaze[y][x] = { ...newMaze[y][x], item: type }; placed = true; }
                    attempts++;
                }
                if (placed) { setMaze(newMaze); toast({ title: "Item Spawned", description: `Spawned ${type}`, className: "bg-slate-800 border-slate-600 text-white" }); }
            };
            if (!maze.length) return null;
            return (
                <div className="min-h-screen bg-background flex items-center justify-center font-mono relative overflow-hidden">
                    
                    {/* --- LAYOUT MATCHING SCREENSHOT --- */}
                    
                    {/* LEVEL INDICATOR (Left) */}
                    <div className="absolute left-[15%] top-[25%] flex flex-col items-start z-10">
                        <h2 className="text-neon-purple text-xs tracking-[0.2em] uppercase font-mono mb-2 opacity-80">LEVEL</h2>
                        <div className="flex items-center gap-4">
                            <div className="flex items-center justify-center w-8 h-8 bg-yellow-900/40 border border-yellow-600/50 rounded">
                                <Ticket size={16} className="text-yellow-500" />
                            </div>
                            <div className="text-4xl font-press text-white text-glow-white">
                                {String(level).padStart(2, '0')}
                            </div>
                            <div className="w-3 h-3 rounded-full bg-green-500 shadow-[0_0_10px_rgba(34,197,94,0.8)]" />
                        </div>
                    </div>
                    {/* TIME INDICATOR (Right) */}
                    <div className="absolute right-[15%] top-[25%] flex flex-col items-end z-10">
                        <h2 className="text-neon-pink text-xs tracking-[0.2em] uppercase font-mono mb-2 opacity-80">TIME</h2>
                        <div className="text-4xl font-press text-white text-glow-white">
                            {Math.floor(timeLeft)}s
                        </div>
                    </div>
                    {/* MAZE (Center) */}
                    <div className="relative z-20 scale-125">
                        <MazeRenderer maze={maze} cellSize={CELL_SIZE} playerPos={playerPos} solutionPath={solutionPath} isSpeedActive={isSpeedActive} skin={activeSkin} />
                    </div>
                    {/* BOTTOM CONTROLS - FIXED VISIBILITY */}
                    <div className="fixed bottom-8 left-8 z-30 flex gap-4">
                        <Button onClick={openPack} disabled={packsAvailable === 0 || isOpeningPack} className={`font-mono text-xs h-10 px-6 border bg-[#2a2a35] text-gray-300 border-gray-600 hover:bg-[#3a3a45] hover:text-white ${packsAvailable > 0 ? 'animate-pulse border-neon-purple text-white' : ''}`}>
                            <Package className="w-4 h-4 mr-2" /> PACKS ({packsAvailable})
                        </Button>
                        
                        {/* DIRECT BUTTONS - NOT WRAPPED IN DIALOG TRIGGER */}
                        <Button onClick={() => setIsShopOpen(true)} className="font-mono text-xs h-10 px-6 border bg-[#2a2a35] text-gray-300 border-gray-600 hover:bg-[#3a3a45] hover:text-white">
                            <ShoppingCart className="w-4 h-4 mr-2" /> SHOP
                        </Button>
                        <Button onClick={() => setIsSkinsOpen(true)} className="font-mono text-xs h-10 px-6 border bg-[#2a2a35] text-gray-300 border-gray-600 hover:bg-[#3a3a45] hover:text-white">
                            <Palette className="w-4 h-4 mr-2" /> SKINS
                        </Button>
                        <Button onClick={() => setIsAdminOpen(true)} className="font-mono text-xs h-10 px-6 border bg-[#2a2a35] text-gray-300 border-gray-600 hover:bg-[#3a3a45] hover:text-white">
                            ADMIN
                        </Button>
                        {/* MODALS - DECOUPLED FROM BUTTONS */}
                        <Modal open={isShopOpen} onClose={() => setIsShopOpen(false)} className="border-yellow-500 text-white">
                            <ModalHeader>
                                <ModalTitle className="text-yellow-500 font-press text-sm flex items-center gap-2"><ShoppingCart size={18} /> BLACK MARKET</ModalTitle>
                                <ModalDescription className="text-gray-400 text-xs">BALANCE: <span className="text-yellow-400 font-bold">{coins} Coins</span></ModalDescription>
                            </ModalHeader>
                            <div className="grid grid-cols-2 gap-3 py-4">
                                <Button variant="outline" onClick={() => buyPowerUp('speed', 50)} className="flex flex-col h-auto py-3 border-blue-500/50 hover:bg-blue-950/50 text-blue-400"><div className="flex items-center gap-1 mb-1"><Zap size={16} /> SPEED</div><span className="text-[10px] text-gray-400">50 Coins</span></Button>
                                <Button variant="outline" onClick={() => buyPowerUp('time', 50)} className="flex flex-col h-auto py-3 border-green-500/50 hover:bg-green-950/50 text-green-400"><div className="flex items-center gap-1 mb-1"><Clock size={16} /> TIME</div><span className="text-[10px] text-gray-400">50 Coins</span></Button>
                                <Button variant="outline" onClick={() => buyPowerUp('vision', 50)} className="flex flex-col h-auto py-3 border-purple-500/50 hover:bg-purple-950/50 text-purple-400"><div className="flex items-center gap-1 mb-1"><Eye size={16} /> VISION</div><span className="text-[10px] text-gray-400">50 Coins</span></Button>
                                <Button variant="outline" onClick={() => buyPowerUp('ghost', 50)} className="flex flex-col h-auto py-3 border-white/50 hover:bg-gray-800 text-white"><div className="flex items-center gap-1 mb-1"><Footprints size={16} /> GHOST</div><span className="text-[10px] text-gray-400">50 Coins</span></Button>
                                <Button variant="outline" onClick={() => buyPowerUp('freeze', 50)} className="flex flex-col h-auto py-3 border-cyan-500/50 hover:bg-cyan-950/50 text-cyan-400 col-span-2"><div className="flex items-center gap-1 mb-1"><Snowflake size={16} /> FREEZE</div><span className="text-[10px] text-gray-400">50 Coins</span></Button>
                                <Button variant="destructive" onClick={buySkipLevel} className="col-span-2 bg-red-900/50 hover:bg-red-800 border border-red-500 flex justify-between"><span className="flex items-center gap-2"><SkipForward size={16} /> SKIP LEVEL</span><span className="text-yellow-400 font-bold">150 Coins</span></Button>
                            </div>
                        </Modal>
                        <Modal open={isSkinsOpen} onClose={() => setIsSkinsOpen(false)} className="border-neon-cyan text-white">
                            <ModalHeader><ModalTitle className="text-neon-cyan font-press text-sm">CUSTOMIZATION</ModalTitle></ModalHeader>
                            <div className="grid grid-cols-3 gap-2 max-h-[60vh] overflow-y-auto pr-2">
                                {Object.entries(SKIN_RARITIES).map(([skin, rarity]) => {
                                    if (rarity === 'Special' && !unlockedSkins.includes(skin)) return null;
                                    const isUnlocked = unlockedSkins.includes(skin);
                                    let rarityColor = 'text-gray-500';
                                    if (rarity === 'Uncommon') rarityColor = 'text-blue-400';
                                    if (rarity === 'Rare') rarityColor = 'text-purple-400';
                                    if (rarity === 'Epic') rarityColor = 'text-yellow-400';
                                    if (rarity === 'Legendary') rarityColor = 'text-orange-500';
                                    if (rarity === 'Mythic') rarityColor = 'text-red-500 font-bold';
                                    return (
                                        <button key={skin} disabled={!isUnlocked} onClick={() => setActiveSkin(skin)} className={`relative flex flex-col items-center p-2 rounded border-2 ${activeSkin === skin ? 'border-neon-pink bg-pink-900/20' : 'border-gray-800 bg-black/50'} ${!isUnlocked ? 'opacity-50 grayscale' : ''}`}>
                                            <div className="mb-2 scale-75"><MazeRenderer maze={[[{x:0,y:0,top:false,bottom:false,left:false,right:false}]]} cellSize={20} playerPos={{x:0,y:0}} skin={skin} /></div>
                                            <span className="text-[10px] uppercase font-bold">{skin}</span>
                                            <span className={`text-[8px] ${rarityColor}`}>{rarity}</span>
                                            {!isUnlocked && <div className="absolute inset-0 flex items-center justify-center bg-black/60"><Lock size={12} className="text-gray-500" /></div>}
                                        </button>
                                    );
                                })}
                            </div>
                        </Modal>
                        
                         <Modal open={isAdminOpen} onClose={() => setIsAdminOpen(false)} className="border-neon-purple text-white">
                            <ModalHeader><ModalTitle className="text-neon-purple font-press text-sm">SYSTEM OVERRIDE</ModalTitle></ModalHeader>
                            {!isAdminAuthenticated ? (
                                <div className="space-y-4">
                                    <Input type="password" value={adminPassword} onChange={(e) => setAdminPassword(e.target.value)} className="bg-gray-900 border-gray-700 text-white" placeholder="ENTER CODE" />
                                    <Button onClick={handleAdminLogin} className="w-full bg-neon-purple text-white font-press text-xs">AUTHENTICATE</Button>
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    <div className="flex justify-between items-center"><span className="text-sm">Freeze Time</span><Switch checked={isTimeFrozen} onCheckedChange={setIsTimeFrozen} /></div>
                                    <div className="flex justify-between items-center"><span className="text-sm">Vision</span><Switch checked={isVisionUnlimited} onCheckedChange={setIsVisionUnlimited} /></div>
                                    <Button variant="secondary" size="sm" onClick={nextLevel} className="w-full">SKIP LEVEL</Button>
                                    <div className="grid grid-cols-3 gap-2">
                                        <Button variant="outline" size="sm" onClick={() => spawnPowerUp('speed')} className="text-blue-400">Speed</Button>
                                        <Button variant="outline" size="sm" onClick={() => spawnPowerUp('time')} className="text-yellow-400">Time</Button>
                                        <Button variant="outline" size="sm" onClick={() => spawnPowerUp('ghost')} className="text-purple-400">Ghost</Button>
                                    </div>
                                </div>
                            )}
                        </Modal>
                    </div>
                    {/* STORY CUTSCENE OVERLAY */}
                    {storyState !== 'none' && (
                        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/95 p-8 rounded-lg">
                            <div className="text-center space-y-8">
                                <Skull className="w-32 h-32 text-red-600 animate-bounce mx-auto" />
                                <div className="bg-gray-900/80 border-2 border-red-800 p-6 rounded-lg"><p className="font-press text-red-500 text-lg">{currentDialog[storyStep]}</p></div>
                                <Button onClick={advanceStory} className="bg-red-700 hover:bg-red-600 text-white font-press py-6 px-12 w-full">{storyStep < currentDialog.length - 1 ? "NEXT >" : "FIGHT!"}</Button>
                            </div>
                        </div>
                    )}
                    
                    {/* GAME OVER / VICTORY OVERLAY */}
                    {gameState !== "playing" && !showCutscene && (
                        <div className="absolute inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center rounded-lg z-20">
                            <Card className="bg-black border-2 border-white p-8 text-center w-80">
                                {gameState === "won" ? (
                                    <>
                                        <Trophy className="w-16 h-16 text-yellow-400 mx-auto mb-4" />
                                        <h2 className="text-2xl font-press text-green-400 mb-2">ESCAPED!</h2>
                                        <Button onClick={nextLevel} className="w-full bg-neon-cyan hover:bg-cyan-400 text-black font-bold font-press mt-4 py-6">NEXT LEVEL</Button>
                                    </>
                                ) : (
                                    <>
                                        <Timer className="w-16 h-16 text-red-500 mx-auto mb-4" />
                                        <h2 className="text-2xl font-press text-red-500 mb-2">TIME OUT</h2>
                                        <Button onClick={retry} className="w-full bg-white hover:bg-gray-200 text-black font-bold font-press mt-4 py-6">TRY AGAIN</Button>
                                        <Button variant="ghost" onClick={() => setLevel(1)} className="w-full text-gray-500 mt-2">Reset</Button>
                                    </>
                                )}
                            </Card>
                        </div>
                    )}
                    {/* OPENING PACK ANIMATION */}
                    {isOpeningPack && (
                        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/95 backdrop-blur-md">
                            <div className="flex flex-col items-center text-center">
                                {openingStage === 'ready' && (
                                    <div className="animate-in zoom-in duration-300 cursor-pointer group" onClick={revealPack}>
                                        <Package className="w-40 h-40 text-neon-purple group-hover:scale-110 transition-transform drop-shadow-[0_0_30px_rgba(168,85,247,0.5)]" />
                                        <h2 className="text-3xl font-press text-white mt-8 animate-bounce">CLICK TO OPEN</h2>
                                    </div>
                                )}
                                {openingStage === 'shaking' && (
                                    <div className="animate-shake"><Package className="w-40 h-40 text-white" /></div>
                                )}
                                {openingStage === 'revealed' && packResult && (
                                    <div className="animate-in zoom-in duration-500 flex flex-col items-center">
                                        <div className="scale-150 mb-8"><MazeRenderer maze={[[{x:0,y:0,top:false,bottom:false,left:false,right:false}]]} cellSize={60} playerPos={{x:0,y:0}} skin={packResult} /></div>
                                        <h2 className="text-4xl font-press text-white mb-2">{packResult.toUpperCase()}</h2>
                                        <div className="font-mono text-xl mb-2 px-6 py-2 rounded border-2 border-neon-pink text-neon-pink">{SKIN_RARITIES[packResult]}</div>
                                        <p className="text-gray-400 font-mono text-sm mb-8">
                                            {SKIN_RARITIES[packResult] === 'Mythic' ? '0.5%' : SKIN_RARITIES[packResult] === 'Legendary' ? '5%' : SKIN_RARITIES[packResult] === 'Epic' ? '10%' : SKIN_RARITIES[packResult] === 'Rare' ? '14.5%' : SKIN_RARITIES[packResult] === 'Uncommon' ? '20%' : '50%'} Chance
                                        </p>
                                        <Button onClick={closePack} className="bg-white text-black font-press px-8 py-6 text-lg hover:bg-gray-200">CONTINUE</Button>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        function AppWithToast() {
            const [toasts, setToasts] = useState([]);
            const toast = useCallback(({ title, description, className, variant }) => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, title, description, className, variant }].slice(-3));
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 1500);
            }, []);
            return (
                <ToastContext.Provider value={{ toasts, toast }}>
                    <Game />
                    <Toaster />
                </ToastContext.Provider>
            );
        }
        root.render(<AppWithToast />);
    </script>
</body>
</html>
