<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>3D Game Fixed</title>
<style>
  html,body {margin:0;overflow:hidden;height:100%;background:#000;color:white;font-family:sans-serif;}
  #info{position:absolute;top:10px;width:100%;text-align:center;z-index:1;}
</style>
</head>
<body>
<div id="info">Use W A S D to move | Move mouse to look around</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
let camera, scene, renderer;
const keys = {};
let pitch = 0, yaw = 0;
const moveSpeed = 0.2;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // sky

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 5);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5,10,5);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));

  // floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshPhongMaterial({color:0xffffff})
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // cube
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(2,2,2),
    new THREE.MeshPhongMaterial({color:0xff0000})
  );
  cube.position.set(0,1,0);
  scene.add(cube);

  // random boxes
  const wallGeo = new THREE.BoxGeometry(2,2,2);
  const wallMat = new THREE.MeshPhongMaterial({color:0x2196f3});
  for(let i=0;i<40;i++){
    const w = new THREE.Mesh(wallGeo, wallMat);
    w.position.set(Math.random()*80-40, 1, Math.random()*80-40);
    scene.add(w);
  }

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  document.addEventListener('keydown', e => keys[e.code] = true);
  document.addEventListener('keyup', e => keys[e.code] = false);

  // Mouse look
  document.addEventListener('mousemove', e => {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    camera.rotation.set(pitch, yaw, 0);
  });
}

function animate(){
  requestAnimationFrame(animate);
  movePlayer();
  renderer.render(scene, camera);
}

function movePlayer(){
  const dir = new THREE.Vector3();
  if(keys['KeyW']) dir.z -= 1;
  if(keys['KeyS']) dir.z += 1;
  if(keys['KeyA']) dir.x -= 1;
  if(keys['KeyD']) dir.x += 1;
  dir.normalize();

  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(Math.sin(yaw + Math.PI/2), 0, Math.cos(yaw + Math.PI/2));

  camera.position.addScaledVector(forward, dir.z * moveSpeed);
  camera.position.addScaledVector(right, dir.x * moveSpeed);
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
