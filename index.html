<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ultimate Dungeon Maze - Premium Edition</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    font-family: 'Cinzel', 'Georgia', serif;
    background: #000;
    overflow: hidden;
    cursor: none;
  }

  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

  #gameCanvas { display: block; }

  /* Vignette effect */
  #vignette {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.8) 100%);
    z-index: 5;
  }

  /* Crosshair */
  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 4px; height: 4px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(100,200,255,0.6);
    z-index: 6;
    pointer-events: none;
  }

  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255,255,255,0.5);
  }

  #crosshair::before {
    top: 50%; left: -12px;
    transform: translateY(-50%);
    width: 8px; height: 1px;
  }

  #crosshair::after {
    left: 50%; top: -12px;
    transform: translateX(-50%);
    width: 1px; height: 8px;
  }

  /* HUD */
  .hud-container {
    position: fixed;
    z-index: 10;
    color: #fff;
    text-shadow: 0 0 10px rgba(0,0,0,0.9), 0 2px 4px rgba(0,0,0,0.8);
  }

  #topLeft {
    top: 25px; left: 25px;
    background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(40,10,10,0.75));
    padding: 20px;
    border-radius: 15px;
    border: 2px solid rgba(255,100,100,0.4);
    box-shadow: 0 8px 32px rgba(0,0,0,0.8), inset 0 0 20px rgba(255,50,50,0.1);
    backdrop-filter: blur(10px);
    min-width: 220px;
  }

  #topRight {
    top: 25px; right: 25px;
    background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(10,10,40,0.75));
    padding: 20px;
    border-radius: 15px;
    border: 2px solid rgba(100,100,255,0.4);
    box-shadow: 0 8px 32px rgba(0,0,0,0.8);
    backdrop-filter: blur(10px);
    text-align: right;
  }

  .hud-title {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 15px;
    letter-spacing: 2px;
    color: #ff6666;
    text-transform: uppercase;
  }

  .stat-row {
    margin: 12px 0;
    font-size: 15px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
  }

  .stat-label {
    color: #aaa;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .stat-value {
    color: #fff;
    font-size: 18px;
    font-weight: 700;
  }

  /* Health Bar */
  #healthBarContainer {
    width: 100%;
    height: 24px;
    background: rgba(0,0,0,0.7);
    border-radius: 12px;
    overflow: hidden;
    margin-top: 10px;
    border: 2px solid rgba(255,100,100,0.5);
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.8);
  }

  #healthBar {
    height: 100%;
    background: linear-gradient(90deg, #ff3333, #ff6633, #ffaa33);
    width: 100%;
    transition: width 0.3s ease, background 0.3s;
    box-shadow: 0 0 20px rgba(255,100,100,0.8);
    position: relative;
    overflow: hidden;
  }

  #healthBar::after {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
  }

  @keyframes shimmer {
    to { left: 100%; }
  }

  /* Messages */
  #message {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    padding: 40px 60px;
    background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(20,20,60,0.95));
    border: 3px solid rgba(100,200,255,0.6);
    border-radius: 20px;
    box-shadow: 0 0 60px rgba(100,200,255,0.5), inset 0 0 40px rgba(0,0,0,0.5);
    font-size: 28px;
    text-align: center;
    display: none;
    backdrop-filter: blur(15px);
    animation: messageAppear 0.3s ease-out;
  }

  @keyframes messageAppear {
    from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  #message.victory {
    background: linear-gradient(135deg, rgba(20,60,20,0.95), rgba(40,80,40,0.95));
    border-color: rgba(100,255,100,0.6);
    box-shadow: 0 0 60px rgba(100,255,100,0.5), inset 0 0 40px rgba(0,0,0,0.5);
  }

  #message.death {
    background: linear-gradient(135deg, rgba(60,0,0,0.95), rgba(40,0,0,0.95));
    border-color: rgba(255,50,50,0.6);
    box-shadow: 0 0 60px rgba(255,50,50,0.5), inset 0 0 40px rgba(0,0,0,0.5);
  }

  /* Instructions */
  #instructions {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    padding: 15px 30px;
    border-radius: 10px;
    border: 1px solid rgba(100,200,255,0.3);
    z-index: 10;
    text-align: center;
    backdrop-filter: blur(10px);
  }

  .key {
    display: inline-block;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 5px;
    padding: 4px 10px;
    margin: 0 3px;
    font-weight: 700;
    font-size: 14px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
  }

  /* Loading screen */
  #loading {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    color: #fff;
  }

  .spinner {
    width: 60px;
    height: 60px;
    border: 4px solid rgba(100,200,255,0.2);
    border-top-color: #6cf;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Mini-map */
  #minimap {
    position: fixed;
    bottom: 30px;
    right: 30px;
    width: 200px;
    height: 200px;
    background: rgba(0,0,0,0.85);
    border: 2px solid rgba(100,200,255,0.4);
    border-radius: 10px;
    z-index: 10;
    backdrop-filter: blur(10px);
  }

  /* Damage indicator */
  .damage-indicator {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: radial-gradient(circle at center, transparent 30%, rgba(255,0,0,0.4) 100%);
    pointer-events: none;
    z-index: 4;
    opacity: 0;
    animation: damageFlash 0.3s ease-out;
  }

  @keyframes damageFlash {
    0% { opacity: 0; }
    50% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* Attack cooldown indicator */
  #attackCooldown {
    position: fixed;
    bottom: 50%;
    left: 50%;
    transform: translate(-50%, 150px);
    width: 100px;
    height: 8px;
    background: rgba(0,0,0,0.6);
    border-radius: 4px;
    overflow: hidden;
    z-index: 6;
  }

  #attackCooldownBar {
    height: 100%;
    background: linear-gradient(90deg, #ff6600, #ffaa00);
    width: 0%;
    transition: width 0.05s linear;
    box-shadow: 0 0 10px rgba(255,150,0,0.8);
  }
</style>
</head>
<body>

<div id="loading">
  <div class="spinner"></div>
  <h2 style="font-size: 32px; margin-bottom: 10px;">⚔️ DUNGEON MAZE ⚔️</h2>
  <p style="color: #888; font-size: 16px;">Loading assets...</p>
</div>

<div id="vignette"></div>
<div id="crosshair"></div>

<div id="topLeft" class="hud-container">
  <div class="hud-title">⚔️ Status</div>
  <div class="stat-row">
    <span class="stat-label">Health</span>
    <span class="stat-value" id="healthText">100</span>
  </div>
  <div id="healthBarContainer">
    <div id="healthBar"></div>
  </div>
  <div class="stat-row" style="margin-top: 15px;">
    <span class="stat-label">Enemies</span>
    <span class="stat-value" id="enemyCount">0</span>
  </div>
  <div class="stat-row">
    <span class="stat-label">Score</span>
    <span class="stat-value" id="score">0</span>
  </div>
</div>

<div id="topRight" class="hud-container">
  <div class="stat-row">
    <span class="stat-label">FPS</span>
    <span class="stat-value" id="fps">60</span>
  </div>
  <div class="stat-row">
    <span class="stat-label">Level</span>
    <span class="stat-value" id="level">1</span>
  </div>
</div>

<div id="instructions">
  <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move &nbsp;•&nbsp;
  <span class="key">Mouse</span> Look &nbsp;•&nbsp;
  <span class="key">Click</span> Attack &nbsp;•&nbsp;
  <span class="key">R</span> Restart &nbsp;•&nbsp;
  <span class="key">ESC</span> Release Pointer
</div>

<div id="attackCooldown">
  <div id="attackCooldownBar"></div>
</div>

<canvas id="minimap"></canvas>

<div id="message"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ========================
// GAME CONFIGURATION
// ========================
const CONFIG = {
  maze: { width: 21, height: 21, cellSize: 2.5 },
  player: { height: 1.7, speed: 3.5, radius: 0.4, maxHealth: 100 },
  monster: { count: 10, speed: 1.3, damage: 8, hp: 5, detectRange: 15 },
  combat: { swordDamage: 1, swordRange: 2.5, cooldown: 0.45, knockback: 1.2 },
  graphics: { 
    shadowQuality: 2048, 
    fogDensity: 0.045,
    particleCount: 800,
    torchCount: 8
  }
};

// ========================
// GLOBAL STATE
// ========================
const STATE = {
  player: {
    health: CONFIG.player.maxHealth,
    score: 0,
    level: 1,
    yaw: 0,
    pitch: 0,
    canMove: true
  },
  combat: {
    swinging: false,
    swingTimer: 0,
    cooldown: 0
  },
  input: {
    keys: {},
    pointerLocked: false
  },
  game: {
    monsters: [],
    walls: [],
    particles: [],
    effects: []
  }
};

// ========================
// DOM ELEMENTS
// ========================
const DOM = {
  healthText: document.getElementById('healthText'),
  healthBar: document.getElementById('healthBar'),
  enemyCount: document.getElementById('enemyCount'),
  score: document.getElementById('score'),
  fps: document.getElementById('fps'),
  level: document.getElementById('level'),
  message: document.getElementById('message'),
  instructions: document.getElementById('instructions'),
  loading: document.getElementById('loading'),
  attackCooldownBar: document.getElementById('attackCooldownBar'),
  minimap: document.getElementById('minimap')
};

// ========================
// THREE.JS SETUP
// ========================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020208);
scene.fog = new THREE.FogExp2(0x020208, CONFIG.graphics.fogDensity);

const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.y = CONFIG.player.height;

const renderer = new THREE.WebGLRenderer({ 
  antialias: true, 
  powerPreference: "high-performance",
  canvas: document.getElementById('gameCanvas') || document.createElement('canvas')
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;
document.body.insertBefore(renderer.domElement, document.body.firstChild);

// ========================
// AUDIO SYSTEM
// ========================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

class AudioManager {
  static play(type) {
    const sounds = {
      swing: () => {
        this.tone(600, 0.08, 'triangle', 0.12);
        this.tone(350, 0.12, 'sine', 0.06);
      },
      hit: () => {
        this.tone(220, 0.08, 'sawtooth', 0.15);
        this.tone(880, 0.15, 'square', 0.06);
        this.tone(140, 0.1, 'sine', 0.08);
      },
      damage: () => {
        this.tone(180, 0.18, 'sawtooth', 0.12);
        this.tone(90, 0.25, 'sine', 0.1);
      },
      death: () => {
        this.tone(150, 0.3, 'sawtooth', 0.15);
        this.tone(75, 0.5, 'sine', 0.12);
      },
      victory: () => {
        this.tone(523, 0.15, 'sine', 0.1);
        setTimeout(() => this.tone(659, 0.15, 'sine', 0.1), 150);
        setTimeout(() => this.tone(784, 0.3, 'sine', 0.1), 300);
      }
    };
    
    if(sounds[type]) sounds[type]();
  }

  static tone(freq, duration, type = 'sine', volume = 0.1) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
  }
}

// ========================
// LIGHTING SYSTEM
// ========================
function setupLighting() {
  // Ambient
  const ambient = new THREE.AmbientLight(0x2244aa, 0.15);
  scene.add(ambient);

  // Moonlight
  const moon = new THREE.DirectionalLight(0x6688ff, 0.5);
  moon.position.set(25, 50, 25);
  moon.castShadow = true;
  moon.shadow.mapSize.set(CONFIG.graphics.shadowQuality, CONFIG.graphics.shadowQuality);
  moon.shadow.camera.left = moon.shadow.camera.bottom = -60;
  moon.shadow.camera.right = moon.shadow.camera.top = 60;
  moon.shadow.bias = -0.0005;
  scene.add(moon);

  // Rim light
  const rim = new THREE.DirectionalLight(0xff6633, 0.25);
  rim.position.set(-20, 15, -20);
  scene.add(rim);

  // Torch lights
  const torches = [];
  for(let i = 0; i < CONFIG.graphics.torchCount; i++) {
    const torch = new THREE.PointLight(
      new THREE.Color().setHSL(0.08 + Math.random() * 0.05, 1, 0.5),
      2.5, 
      18, 
      2
    );
    torch.castShadow = true;
    torch.shadow.mapSize.set(512, 512);
    scene.add(torch);
    torches.push(torch);
  }

  // Player flashlight
  const flashlight = new THREE.SpotLight(0xffffdd, 1.8, 25, Math.PI / 5, 0.4, 1.8);
  flashlight.castShadow = true;
  flashlight.shadow.mapSize.set(1024, 1024);
  camera.add(flashlight);
  camera.add(flashlight.target);
  flashlight.target.position.set(0, 0, -5);
  scene.add(camera);

  return { torches };
}

const lighting = setupLighting();

// ========================
// TEXTURE GENERATION
// ========================
function createTexture(draw, size = 512) {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  draw(ctx, size);
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  return texture;
}

const textures = {
  wall: createTexture((ctx, s) => {
    ctx.fillStyle = '#1a1520';
    ctx.fillRect(0, 0, s, s);
    for(let y = 0; y < s; y += 80) {
      for(let x = 0; x < s; x += 150) {
        const offset = (y / 80) % 2 ? 75 : 0;
        ctx.fillStyle = `rgb(${20 + Math.random() * 15}, ${15 + Math.random() * 10}, ${25 + Math.random() * 15})`;
        ctx.fillRect(x + offset, y, 145, 75);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(x + offset, y, 145, 75);
      }
    }
  }),
  
  floor: createTexture((ctx, s) => {
    ctx.fillStyle = '#1a1a22';
    ctx.fillRect(0, 0, s, s);
    for(let y = 0; y < s; y += 100) {
      for(let x = 0; x < s; x += 100) {
        ctx.fillStyle = `rgb(${20 + Math.random() * 12}, ${20 + Math.random() * 12}, ${28 + Math.random() * 15})`;
        ctx.fillRect(x + 2, y + 2, 96, 96);
        if(Math.random() < 0.3) {
          ctx.strokeStyle = 'rgba(0,0,0,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + Math.random() * 100, y + Math.random() * 100);
          ctx.lineTo(x + Math.random() * 100, y + Math.random() * 100);
          ctx.stroke();
        }
      }
    }
  })
};

textures.floor.repeat.set(10, 10);

// ========================
// ENVIRONMENT
// ========================
function createEnvironment() {
  // Floor
  const floorGeo = new THREE.PlaneGeometry(200, 200, 60, 60);
  const floorMat = new THREE.MeshStandardMaterial({ 
    map: textures.floor, 
    roughness: 0.95, 
    metalness: 0.05 
  });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  
  // Add height variation
  const pos = floorGeo.attributes.position;
  for(let i = 0; i < pos.count; i++) {
    pos.setZ(i, Math.random() * 0.08);
  }
  pos.needsUpdate = true;
  floorGeo.computeVertexNormals();
  
  scene.add(floor);

  // Ceiling
  const ceilingGeo = new THREE.PlaneGeometry(200, 200);
  const ceilingMat = new THREE.MeshStandardMaterial({ 
    color: 0x0a0a15, 
    roughness: 1, 
    side: THREE.DoubleSide 
  });
  const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = CONFIG.maze.cellSize * 1.8;
  ceiling.receiveShadow = true;
  scene.add(ceiling);

  // Atmospheric particles
  const particleGeo = new THREE.BufferGeometry();
  const positions = new Float32Array(CONFIG.graphics.particleCount * 3);
  const velocities = [];

  for(let i = 0; i < CONFIG.graphics.particleCount; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 180;
    positions[i * 3 + 1] = Math.random() * 4;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 180;
    velocities.push(new THREE.Vector3(
      (Math.random() - 0.5) * 0.008,
      Math.random() * 0.012 + 0.004,
      (Math.random() - 0.5) * 0.008
    ));
  }

  particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const particleMat = new THREE.PointsMaterial({
    color: 0x5588ff,
    size: 0.04,
    transparent: true,
    opacity: 0.5,
    blending: THREE.AdditiveBlending
  });
  const particles = new THREE.Points(particleGeo, particleMat);
  scene.add(particles);

  return { particles, velocities };
}

const environment = createEnvironment();

// ========================
// MAZE GENERATION
// ========================
class MazeGenerator {
  constructor(w, h) {
    this.w = w % 2 === 0 ? w + 1 : w;
    this.h = h % 2 === 0 ? h + 1 : h;
    this.grid = Array(this.h).fill().map(() => Array(this.w).fill('#'));
  }

  generate() {
    const stack = [{x: 1, z: 1}];
    this.grid[1][1] = '.';
    const dirs = [{x:0,z:-2}, {x:2,z:0}, {x:0,z:2}, {x:-2,z:0}];

    while(stack.length) {
      const cur = stack[stack.length - 1];
      const neighbors = dirs
        .map(d => ({x: cur.x + d.x, z: cur.z + d.z, dir: d}))
        .filter(n => n.x > 0 && n.z > 0 && n.x < this.w - 1 && n.z < this.h - 1 && this.grid[n.z][n.x] === '#');

      if(!neighbors.length) {
        stack.pop();
      } else {
        const pick = neighbors[Math.floor(Math.random() * neighbors.length)];
        this.grid[cur.z + pick.dir.z / 2][cur.x + pick.dir.x / 2] = '.';
        this.grid[pick.z][pick.x] = '.';
        stack.push(pick);
      }
    }
  }

  buildWalls(scene) {
    const walls = [];
    const offsetX = -(this.w * CONFIG.maze.cellSize) / 2 + CONFIG.maze.cellSize / 2;
    const offsetZ = -(this.h * CONFIG.maze.cellSize) / 2 + CONFIG.maze.cellSize / 2;

    const wallMaterials = [
      new THREE.MeshStandardMaterial({ map: textures.wall, roughness: 0.9, metalness: 0.05 }),
      new THREE.MeshStandardMaterial({ color: 0x2a2535, roughness: 0.88, metalness: 0.08 }),
      new THREE.MeshStandardMaterial({ color: 0x1f1a28, roughness: 0.92, metalness: 0.03 })
    ];

    for(let z = 0; z < this.h; z++) {
      for(let x = 0; x < this.w; x++) {
        if(this.grid[z][x] === '#') {
          const height = CONFIG.maze.cellSize * (1.3 + Math.random() * 0.25);
          const geo = new THREE.BoxGeometry(
            CONFIG.maze.cellSize * 0.98,
            height,
            CONFIG.maze.cellSize * 0.98
          );
          
          const mat = wallMaterials[Math.floor(Math.random() * wallMaterials.length)].clone();
          const mesh = new THREE.Mesh(geo, mat);
          
          mesh.position.set(
            offsetX + x * CONFIG.maze.cellSize,
            height / 2,
            offsetZ + z * CONFIG.maze.cellSize
          );
          
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          walls.push({mesh, x, z});

          // Random glowing accents
          if(Math.random() < 0.12) {
            const glowGeo = new THREE.PlaneGeometry(
              CONFIG.maze.cellSize * 0.25,
              CONFIG.maze.cellSize * 0.25
            );
            const glowMat = new THREE.MeshBasicMaterial({
              color: new THREE.Color().setHSL(0.15 + Math.random() * 0.25, 0.9, 0.45),
              transparent: true,
              opacity: 0.4,
              blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(0, 0, CONFIG.maze.cellSize / 2 + 0.02);
            mesh.add(glow);
          
