<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ultimate Dungeon Maze ‚Äî Full</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#05060a;--muted:#9fbcd6;--accent:#ff6b6b}
  html,body{height:100%;margin:0;background:var(--bg);color:#eaf8ff;font-family:Inter,system-ui,Arial;overflow:hidden}
  /* HUD */
  .status-card{position:fixed;left:20px;top:20px;width:320px;background:linear-gradient(180deg,#071019,#02030a);padding:14px;border-radius:12px;z-index:3000;border:1px solid rgba(255,255,255,0.03);box-shadow:0 12px 34px rgba(0,0,0,0.6)}
  .status-title{font-family:"Playfair Display",serif;color:#ffc6c6;letter-spacing:2px;font-size:18px;margin-bottom:6px}
  .status-row{display:flex;justify-content:space-between;align-items:center}
  .status-label{color:var(--muted);font-size:12px;text-transform:uppercase}
  .status-value{font-weight:700;color:#fff}
  .health-bar-bg{height:14px;background:rgba(255,255,255,0.03);border-radius:10px;overflow:hidden;margin-left:12px}
  .health-bar{height:100%;width:100%;background:linear-gradient(90deg,#ff6644,#ffb86b);transition:width .25s ease}
  .stat-grid{display:flex;gap:10px;margin-top:12px}
  .stat-mini{flex:1;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center}
  .fps-card{position:fixed;right:20px;top:20px;padding:10px;border-radius:10px;background:linear-gradient(180deg,#06101a,#03050a);z-index:3000;border:1px solid rgba(255,255,255,0.03)}
  .minimap{position:fixed;right:20px;bottom:20px;width:220px;height:220px;z-index:3000;padding:10px;border-radius:12px;background:linear-gradient(180deg,#061018,#02040a);border:1px solid rgba(255,255,255,0.03)}
  canvas.minimap-canvas{width:100%;height:100%;display:block;border-radius:8px;background:#081018}
  .crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:6px;height:6px;border-radius:50%;background:#fff;z-index:2500;pointer-events:none;box-shadow:0 0 10px rgba(255,255,255,0.9)}
  .controls-card{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;z-index:2500;color:var(--muted)}
  #loadingOverlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#000;z-index:9999;color:#cfe9ff}
  .spinner{width:46px;height:46px;border-radius:50%;border:4px solid rgba(255,255,255,0.06);border-top-color:#6fbce8;animation:spin 1s linear infinite;margin-bottom:10px}
  @keyframes spin{to{transform:rotate(360deg)}}
  .message{position:fixed;left:50%;top:56px;transform:translateX(-50%);padding:12px 18px;border-radius:10px;background:rgba(0,0,0,0.6);z-index:3000;display:none}
  /* small helper */
  .small { font-size:12px; color:var(--muted); }
</style>
</head>
<body>

<!-- HUD -->
<div class="status-card" aria-live="polite">
  <div class="status-title">‚öîÔ∏è STATUS</div>
  <div class="status-row" style="margin-bottom:10px">
    <div>
      <div class="status-label">Health</div>
      <div class="status-value" id="hud-health">100</div>
    </div>
    <div style="flex:1;margin-left:12px">
      <div class="health-bar-bg"><div id="hud-healthbar" class="health-bar"></div></div>
    </div>
  </div>
  <div class="stat-grid">
    <div class="stat-mini"><div class="small">Enemies</div><div id="hud-enemies" style="font-weight:700;margin-top:6px">0</div></div>
    <div class="stat-mini"><div class="small">Score</div><div id="hud-score" style="font-weight:700;margin-top:6px">0</div></div>
  </div>
</div>

<div class="fps-card">
  <div class="small">FPS</div>
  <div id="hud-fps" style="font-weight:800;font-size:16px">0</div>
  <div style="height:8px"></div>
  <div class="small">Level</div>
  <div id="hud-level" style="font-weight:700;margin-top:6px">1</div>
</div>

<div class="minimap"><canvas id="minimapCanvas" class="minimap-canvas" width="200" height="200"></canvas></div>
<div class="crosshair" id="crosshair"></div>
<div class="controls-card">W A S D ‚Ä¢ Move ‚Ä¢ Mouse ‚Ä¢ Click Attack ‚Ä¢ R Restart</div>
<div id="centerMessage" class="message"></div>

<!-- Loading overlay -->
<div id="loadingOverlay"><div class="spinner"></div><div style="font-weight:700;font-size:18px">Dungeon Maze</div><div style="color:#9fb7d9">Preparing world ‚Äî visible now</div></div>

<!-- Load UMD Three.js BEFORE main script (this avoids "Three.js missing") -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* Full single-file game (Claude-style) using THREE global (UMD).
   Save this file and open in browser. No external server assets required.
*/

if(typeof THREE === 'undefined'){
  document.body.innerHTML = '<div style="color:#fff;padding:20px;">Three.js missing ‚Äî ensure three.min.js is loaded.</div>';
  throw new Error('Three.js not present');
}

/* ------------------------------
   Quick helpers & config
   ------------------------------ */
const CONFIG = {
  maze: { w:21, h:21, cell:2.5 },
  player: { height:1.7, speed:3.6, radius:0.36, maxHealth:100 },
  monster: { count:10, speed:1.25, hp:5 },
  combat: { range:2.6, damage:1, cooldown:0.45 },
  graphics: { particles:500 }
};

/* ------------------------------
   Renderer / Scene / Camera
   ------------------------------ */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.shadowMap.enabled = true;
document.body.insertBefore(renderer.domElement, document.body.firstChild);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070814);
scene.fog = new THREE.FogExp2(0x070814, 0.04);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0, CONFIG.player.height, 0);

/* Resize */
window.addEventListener('resize', ()=> {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ------------------------------
   Fast procedural textures (instant)
   ------------------------------ */
function makeCanvasTexture(draw, size=256){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d'); draw(ctx, size);
  const tex = new THREE.CanvasTexture(c); tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 2;
  return tex;
}
const floorTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle='#0f1116'; ctx.fillRect(0,0,s,s);
  for(let y=0;y<s;y+=18) for(let x=0;x<s;x+=18){ ctx.fillStyle=`rgb(${10+Math.random()*8},${10+Math.random()*8},${16+Math.random()*8})`; ctx.fillRect(x+2,y+2,14,14); }
});
floorTex.repeat = new THREE.Vector2(18,18);

const wallTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle='#121318'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle='#191a21';
  for(let y=0;y<s;y+=28) for(let x=0;x<s;x+=56) ctx.fillRect(x + ((y/28)%2?6:0), y+2, 46, 16);
});

/* ------------------------------
   Lighting & simple environment
   ------------------------------ */
scene.add(new THREE.HemisphereLight(0x7fb1ff, 0x10121a, 0.28));
const sun = new THREE.DirectionalLight(0xfff6e6, 0.9);
sun.position.set(30,50,20); sun.castShadow=true; sun.shadow.mapSize.set(1024,1024); sun.shadow.bias=-0.0004;
scene.add(sun);
scene.add(new THREE.DirectionalLight(0xffb86b, 0.12));

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(300,300,6,6),
  new THREE.MeshStandardMaterial({ map: floorTex, roughness:0.98 })
);
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

/* ------------------------------
   Maze generation (recursive backtracker)
   ------------------------------ */
class Maze {
  constructor(w,h){
    this.w = (w % 2 === 0) ? w+1 : w;
    this.h = (h % 2 === 0) ? h+1 : h;
    this.grid = Array(this.h).fill().map(()=>Array(this.w).fill('#'));
  }
  generate(){
    const dirs = [{x:0,z:-2},{x:2,z:0},{x:0,z:2},{x:-2,z:0}];
    const stack = [{x:1,z:1}];
    this.grid[1][1] = '.';
    while(stack.length){
      const cur = stack[stack.length-1];
      const neighbors = [];
      for(const d of dirs){
        const nx = cur.x + d.x, nz = cur.z + d.z;
        if(nx>0 && nz>0 && nx<this.w-1 && nz<this.h-1 && this.grid[nz][nx] === '#') neighbors.push({x:nx,z:nz,dir:d});
      }
      if(neighbors.length===0) stack.pop();
      else {
        const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
        this.grid[cur.z + pick.dir.z/2][cur.x + pick.dir.x/2] = '.';
        this.grid[pick.z][pick.x] = '.';
        stack.push({x:pick.x, z:pick.z});
      }
    }
    // entrance/exit
    this.grid[1][0] = '.'; this.grid[this.h-2][this.w-1] = '.';
  }
  buildMeshes(scene){
    // remove old walls if any
    if(this._walls) this._walls.forEach(w=>scene.remove(w.mesh));
    this._walls = [];
    const geo = new THREE.BoxGeometry(CONFIG.maze.cell*0.98, CONFIG.maze.cell*1.08, CONFIG.maze.cell*0.98);
    const mat = new THREE.MeshStandardMaterial({ map: wallTex, roughness:0.95 });
    const offsetX = - (this.w * CONFIG.maze.cell)/2 + CONFIG.maze.cell/2;
    const offsetZ = - (this.h * CONFIG.maze.cell)/2 + CONFIG.maze.cell/2;
    for(let z=0; z<this.h; z++){
      for(let x=0; x<this.w; x++){
        if(this.grid[z][x] === '#'){
          const mesh = new THREE.Mesh(geo, mat.clone());
          mesh.position.set(offsetX + x*CONFIG.maze.cell, (CONFIG.maze.cell*1.08)/2, offsetZ + z*CONFIG.maze.cell);
          mesh.castShadow = true; mesh.receiveShadow = true;
          scene.add(mesh);
          this._walls.push({mesh, x, z});
        }
      }
    }
    this.offsetX = offsetX; this.offsetZ = offsetZ;
    return {walls:this._walls, offsetX, offsetZ};
  }
}

/* ------------------------------
   Build maze & initial position
   ------------------------------ */
const maze = new Maze(CONFIG.maze.w, CONFIG.maze.h);
maze.generate();
const built = maze.buildMeshes(scene);
let WALLS = built.walls;
camera.position.set(built.offsetX + CONFIG.maze.cell, CONFIG.player.height, built.offsetZ + CONFIG.maze.cell);

/* ------------------------------
   Sword (camera-local)
   ------------------------------ */
const swordGroup = new THREE.Group();
const blade = new THREE.Mesh(new THREE.BoxGeometry(0.12,1.08,0.12), new THREE.MeshStandardMaterial({ color:0xe8eef8, metalness:0.95, roughness:0.08 }));
blade.position.set(0.4,-0.58,-1.05);
const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.28,12), new THREE.MeshStandardMaterial({ color:0x523410, roughness:0.8 }));
grip.position.set(0.4,-1.02,-1.05);
swordGroup.add(blade, grip);
camera.add(swordGroup);
scene.add(camera);

/* ------------------------------
   Monsters & particles
   ------------------------------ */
let MONSTERS = [];
let PARTICLES = [];

function spawnMonsters(n){
  for(let i=0;i<n;i++){
    let placed=false, attempts=0;
    while(!placed && attempts++ < 200){
      const rx = Math.floor(Math.random()*(maze.w-2))+1;
      const rz = Math.floor(Math.random()*(maze.h-2))+1;
      if(maze.grid[rz][rx] === '.'){
        const wx = built.offsetX + rx*CONFIG.maze.cell;
        const wz = built.offsetZ + rz*CONFIG.maze.cell;
        if(Math.hypot(wx - camera.position.x, wz - camera.position.z) > CONFIG.maze.cell*4){
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.maze.cell*0.42, CONFIG.maze.cell*0.9, CONFIG.maze.cell*0.42), new THREE.MeshStandardMaterial({ color:0xff6b6b, roughness:0.86 }));
          mesh.position.set(wx, (CONFIG.maze.cell*0.9)/2, wz); mesh.castShadow=true;
          scene.add(mesh);
          MONSTERS.push({mesh, hp:3 + Math.floor(Math.random()*3), velocity:new THREE.Vector3(), atk:0});
          placed=true;
        }
      }
    }
  }
  updateHUDEnemies();
}
spawnMonsters(CONFIG.monster.count);

/* particle spawn */
function spawnHitParticles(x,y,z){
  for(let i=0;i<12;i++){
    const geo = new THREE.SphereGeometry(0.04,6,6);
    const mat = new THREE.MeshBasicMaterial({ color:0xffc6b0, transparent:true, opacity:0.98 });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x,y,z);
    m._vel = new THREE.Vector3((Math.random()-0.5)*1.6, Math.random()*1.6+0.4, (Math.random()-0.5)*1.6);
    m._life = 0.9 + Math.random()*0.6;
    scene.add(m); PARTICLES.push(m);
  }
}

/* ------------------------------
   Collision helper (circle vs box walls)
   ------------------------------ */
function collides(x,z,radius){
  for(const w of WALLS){
    const dx = x - w.mesh.position.x; const dz = z - w.mesh.position.z;
    const half = CONFIG.maze.cell * 0.49;
    const closestX = Math.max(-half, Math.min(half, dx));
    const closestZ = Math.max(-half, Math.min(half, dz));
    const ox = dx - closestX, oz = dz - closestZ;
    if(ox*ox + oz*oz < radius*radius) return true;
  }
  return false;
}

/* ------------------------------
   Input & Pointer Lock
   ------------------------------ */
const STATE = {
  player: { yaw:0, pitch:0, health:CONFIG.player.maxHealth, canMove:true },
  input: { forward:false, back:false, left:false, right:false, pointer:false },
  combat: { swinging:false, timer:0, cooldown:0, _didHit:false }
};

window.addEventListener('keydown', (e)=> {
  if(e.code === 'KeyW') STATE.input.forward = true;
  if(e.code === 'KeyS') STATE.input.back = true;
  if(e.code === 'KeyA') STATE.input.left = true;
  if(e.code === 'KeyD') STATE.input.right = true;
  if(e.code === 'KeyR') restart();
});
window.addEventListener('keyup', (e)=> {
  if(e.code === 'KeyW') STATE.input.forward = false;
  if(e.code === 'KeyS') STATE.input.back = false;
  if(e.code === 'KeyA') STATE.input.left = false;
  if(e.code === 'KeyD') STATE.input.right = false;
});

renderer.domElement.style.cursor = 'pointer';
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock());
document.addEventListener('pointerlockchange', ()=> {
  STATE.input.pointer = document.pointerLockElement === renderer.domElement;
  document.getElementById('crosshair').style.display = STATE.input.pointer ? 'block' : 'none';
});

window.addEventListener('mousemove', (e)=> {
  if(!STATE.input.pointer) return;
  const s = 0.0024;
  STATE.player.yaw -= e.movementX * s;
  STATE.player.pitch -= e.movementY * s;
  STATE.player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, STATE.player.pitch));
  camera.rotation.set(STATE.player.pitch, STATE.player.yaw, 0);
});

/* ------------------------------
   Movement (W is forward, corrected)
   ------------------------------ */
function movePlayer(dt){
  if(!STATE.player.canMove) return;
  // forward vector: camera forward (z negative) corrected
  const forward = new THREE.Vector3(Math.sin(STATE.player.yaw), 0, -Math.cos(STATE.player.yaw));
  const right = new THREE.Vector3(Math.sin(STATE.player.yaw + Math.PI/2), 0, -Math.cos(STATE.player.yaw + Math.PI/2));
  const move = new THREE.Vector3();
  if(STATE.input.forward) move.addScaledVector(forward, 1);
  if(STATE.input.back) move.addScaledVector(forward, -1);
  if(STATE.input.left) move.addScaledVector(right, -1);
  if(STATE.input.right) move.addScaledVector(right, 1);
  if(move.length() > 0.0001){
    move.normalize();
    const nx = camera.position.x + move.x * CONFIG.player.speed * dt;
    const nz = camera.position.z + move.z * CONFIG.player.speed * dt;
    if(!collides(nx, nz, CONFIG.player.radius)){
      camera.position.x = nx; camera.position.z = nz;
    }
  }
}

/* ------------------------------
   Combat / Sword
   ------------------------------ */
window.addEventListener('mousedown', (e)=> {
  if(!STATE.input.pointer || !STATE.player.canMove) return;
  if(e.button === 0) startSwing();
});

function startSwing(){
  if(STATE.combat.cooldown > 0) return false;
  STATE.combat.swinging = true; STATE.combat.timer = 0.01; STATE.combat.cooldown = CONFIG.combat.cooldown; STATE.combat._didHit = false;
  playTone(620, 0.08, 'triangle', 0.06);
  return true;
}

function updateSword(dt){
  if(STATE.combat.cooldown > 0) STATE.combat.cooldown = Math.max(0, STATE.combat.cooldown - dt);
  if(STATE.combat.swinging){
    STATE.combat.timer += dt * 6.5;
    const t = STATE.combat.timer;
    swordGroup.rotation.x = Math.sin(t) * Math.PI * 0.7 - 0.6;
    // hit window
    if(t > Math.PI * 0.28 && t < Math.PI * 0.62 && !STATE.combat._didHit){
      STATE.combat._didHit = true;
      tryHit();
    }
    if(t > Math.PI){
      STATE.combat.swinging = false; STATE.combat.timer = 0; STATE.combat._didHit = false; swordGroup.rotation.x = -0.2;
    }
  } else {
    swordGroup.rotation.x = -0.2 + Math.sin(performance.now() * 0.002) * 0.02;
  }
}

/* Detect hits */
function tryHit(){
  const forward = new THREE.Vector3(Math.sin(STATE.player.yaw), 0, -Math.cos(STATE.player.yaw)).normalize();
  for(let i=MONSTERS.length-1;i>=0;i--){
    const m = MONSTERS[i];
    const toM = m.mesh.position.clone().sub(camera.position);
    const d = toM.length();
    if(d < CONFIG.combat.range){
      toM.y = 0; toM.normalize();
      if(forward.dot(toM) > 0.4){
        m.hp -= CONFIG.combat.damage + Math.floor(Math.random()*2);
        spawnHitParticles(m.mesh.position.x, m.mesh.position.y+0.6, m.mesh.position.z);
        m.velocity.add(forward.clone().multiplyScalar(-1.1));
        playTone(220, 0.08, 'sawtooth', 0.12);
        if(m.hp <= 0){
          scene.remove(m.mesh); MONSTERS.splice(i,1); updateHUDEnemies(); addScore(100);
          if(MONSTERS.length === 0) victory();
        }
        break;
      }
    }
  }
}

/* ------------------------------
   Monster AI
   ------------------------------ */
function updateMonsters(dt){
  for(const m of MONSTERS){
    // apply velocity (knockback)
    if(m.velocity.length() > 0.01){ m.mesh.position.addScaledVector(m.velocity, dt); m.velocity.multiplyScalar(0.88); }
    // move toward player if in range
    const toP = camera.position.clone().sub(m.mesh.position); toP.y = 0; const dist = toP.length();
    if(dist < 18 && dist > 1.6){
      toP.normalize();
      const target = m.mesh.position.clone().addScaledVector(toP, CONFIG.monster.speed * dt);
      if(!collides(target.x, target.z, 0.35)){ m.mesh.position.x = target.x; m.mesh.position.z = target.z; }
    } else if(dist <= 1.6){
      if(!m.atk || m.atk <= 0){ damagePlayer(6 + Math.floor(Math.random()*4)); m.atk = 1.2 + Math.random()*0.6; }
      m.atk = (m.atk || 0) - dt;
    }
    m.mesh.position.y = 0.45 + Math.sin((performance.now() + m.mesh.position.x) * 0.002) * 0.04;
  }
}

/* ------------------------------
   Particles update
   ------------------------------ */
function updateParticles(dt){
  for(let i=PARTICLES.length-1;i>=0;i--){
    const p = PARTICLES[i];
    p._life -= dt;
    p.position.addScaledVector(p._vel, dt);
    p.material.opacity = Math.max(0, p._life);
    if(p._life <= 0){ scene.remove(p); PARTICLES.splice(i,1); }
  }
}

/* ------------------------------
   HUD helpers
   ------------------------------ */
function updateHUDEnemies(){ document.getElementById('hud-enemies').textContent = MONSTERS.length; }
function addScore(n){ const el = document.getElementById('hud-score'); el.textContent = (parseInt(el.textContent||'0') + n); }
function updateHealthUI(){
  const healthEl = document.getElementById('hud-health');
  healthEl.textContent = Math.max(0, Math.floor(STATE.player.health));
  const percent = (STATE.player.health / CONFIG.player.maxHealth) * 100;
  const bar = document.getElementById('hud-healthbar'); bar.style.width = percent + '%';
  if(percent > 65) bar.style.background = 'linear-gradient(90deg,#33ff88,#66ff88,#88ffb3)';
  else if(percent > 35) bar.style.background = 'linear-gradient(90deg,#ffaa33,#ff8833,#ff6633)';
  else bar.style.background = 'linear-gradient(90deg,#ff3333,#ff0000,#cc0000)';
}

/* ------------------------------
   Damage/victory/restart
   ------------------------------ */
function damagePlayer(amount){
  STATE.player.health = Math.max(0, STATE.player.health - amount);
  updateHealthUI();
  flashDamage();
  playTone(180, 0.18, 'sawtooth', 0.11);
  if(STATE.player.health <= 0){
    STATE.player.canMove = false;
    showCenterMessage('üíÄ You Died ‚Äî press R to restart', true);
    playTone(75, 0.6, 'sine', 0.12);
  }
}
function flashDamage(){
  const overlay = document.createElement('div'); overlay.style.position='fixed'; overlay.style.left=overlay.style.top='0'; overlay.style.width=overlay.style.height='100%'; overlay.style.background='radial-gradient(circle at center, transparent 30%, rgba(255,0,0,0.28) 100%)'; overlay.style.zIndex=4000;
  document.body.appendChild(overlay); setTimeout(()=>overlay.remove(), 260);
}
function victory(){
  STATE.player.canMove = false;
  showCenterMessage('‚öîÔ∏è Victory ‚Äî all enemies defeated! Press R to continue', true);
  playTone(523, 0.15, 'sine', 0.08);
}
function restart(){
  // cleanup monsters & particles & walls
  MONSTERS.forEach(m => scene.remove(m.mesh)); MONSTERS = [];
  PARTICLES.forEach(p => scene.remove(p)); PARTICLES = [];
  WALLS.forEach(w => scene.remove(w.mesh)); WALLS = [];
  // regenerate maze
  maze.generate(); const built2 = maze.buildMeshes(scene); WALLS = built2.walls;
  camera.position.set(built2.offsetX + CONFIG.maze.cell, CONFIG.player.height, built2.offsetZ + CONFIG.maze.cell);
  spawnMonsters(CONFIG.monster.count);
  STATE.player.health = CONFIG.player.maxHealth; updateHealthUI(); updateHUDEnemies();
  STATE.player.canMove = true;
  showCenterMessage('Restarted ‚Äî click to lock pointer and play', true);
}

/* ------------------------------
   Simple tone generator
   ------------------------------ */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){ audioCtx = null; } } }
function playTone(freq, dur=0.1, type='sine', vol=0.06){
  ensureAudio(); if(!audioCtx) return;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* ------------------------------
   Minimap
   ------------------------------ */
const miniCanvas = document.getElementById('minimapCanvas'); const miniCtx = miniCanvas.getContext('2d');
function drawMinimap(){
  const w = miniCanvas.width, h = miniCanvas.height;
  miniCtx.clearRect(0,0,w,h); miniCtx.fillStyle='#071018'; miniCtx.fillRect(0,0,w,h);
  const cell = w / maze.w;
  miniCtx.fillStyle = '#26303a';
  for(let z=0; z<maze.h; z++) for(let x=0; x<maze.w; x++) if(maze.grid[z][x] === '#') miniCtx.fillRect(x*cell, z*cell, cell, cell);
  miniCtx.fillStyle = '#ff7b7b'; MONSTERS.forEach(m=>{ const mx = ((m.mesh.position.x/CONFIG.maze.cell)+maze.w/2)*cell; const mz = ((m.mesh.position.z/CONFIG.maze.cell)+maze.h/2)*cell; miniCtx.beginPath(); miniCtx.arc(mx, mz, 3, 0, Math.PI*2); miniCtx.fill(); });
  const px = ((camera.position.x/CONFIG.maze.cell)+maze.w/2)*cell; const pz = ((camera.position.z/CONFIG.maze.cell)+maze.h/2)*cell;
  miniCtx.fillStyle = '#7edb9a'; miniCtx.beginPath(); miniCtx.arc(px, pz, 4, 0, Math.PI*2); miniCtx.fill();
  miniCtx.strokeStyle = '#7edb9a'; miniCtx.lineWidth = 2; miniCtx.beginPath(); miniCtx.moveTo(px,pz); miniCtx.lineTo(px + Math.sin(STATE.player.yaw)*12, pz - Math.cos(STATE.player.yaw)*12); miniCtx.stroke();
}

/* ------------------------------
   Draw loop
   ------------------------------ */
const clock = new THREE.Clock(); let frames=0, accum=0;
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.06);
  // update
  movePlayer(dt);
  updateSword(dt);
  updateMonsters(dt);
  updateParticles(dt);
  drawMinimap();
  // fps
  frames++; accum += dt; if(accum > 0.5){ document.getElementById('hud-fps').textContent = Math.round(frames/accum); frames=0; accum=0; }
  renderer.render(scene, camera);
}
animate();

/* ------------------------------
   HUD startup
   ------------------------------ */
function showCenterMessage(text, autoHide=false){
  const el = document.getElementById('centerMessage'); el.innerHTML = text; el.style.display = 'block';
  if(autoHide) setTimeout(()=> el.style.display='none', 2800);
}
function updateHUDInit(){ document.getElementById('hud-health').textContent = STATE.player.health; updateHealthUI(); updateHUDEnemies(); }
updateHUDInit();

/* Hide loading overlay once the first frame renders (fast)
   also lazy-load nicer textures in background */
requestAnimationFrame(()=> {
  const ld = document.getElementById('loadingOverlay'); if(ld) ld.style.display='none';
  showCenterMessage('Click to lock pointer and play', true);
  // lazy load nicer textures (non-blocking)
  const loader = new THREE.TextureLoader();
  loader.load('https://i.imgur.com/yY6tjqm.jpeg', t => { t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(20,20); floor.material.map = t; floor.material.needsUpdate = true; }, undefined, ()=>{});
  loader.load('https://i.imgur.com/Jd2NPFf.jpeg', t => { t.wrapS=t.wrapT=THREE.RepeatWrapping; WALLS.forEach(w=> w.mesh.material.map = t); }, undefined, ()=>{});
});

/* Expose restart to window for debugging */
window.restart = restart;

</script>
</body>
</html>
