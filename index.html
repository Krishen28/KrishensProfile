<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Block Maze — Combined Game</title>
<style>
  html,body{height:100%;margin:0;background:#050508;color:#fff;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;overflow:hidden;}
  #overlay{position:absolute;left:10px;top:10px;z-index:10;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;}
  #hud{position:absolute;right:10px;top:10px;z-index:10;text-align:right;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;}
  #message{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:12;padding:14px 22px;border-radius:12px;background:rgba(0,0,0,0.6);display:none;}
  #canvas-container{width:100%;height:100%;}
  .small{font-size:12px;color:#ddd;opacity:0.95;margin-top:6px;}
  #fps{font-size:12px;color:#bfefff;}
</style>
</head>
<body>
<div id="overlay">
  <div style="font-weight:700;font-size:16px;">Block Maze — Combined</div>
  <div class="small">W A S D — Move • Mouse — Look • Click — Swing</div>
  <div class="small">Tip: click canvas to lock pointer. Press Esc to release.</div>
</div>
<div id="hud">
  <div id="health">Health: 100</div>
  <div id="monsters">Monsters: 0</div>
  <div id="fps">FPS: 0</div>
</div>
<div id="message"></div>
<div id="canvas-container"></div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
/* Combined single-file game (class-based + long maze + sword + AI)
   - Procedural maze (recursive backtracker)
   - Player/Monster/Sword classes
   - Pointer lock FPS controls
   - Collision detection, sword swing, trail, particles
   - Simple WebAudio sounds
*/

(() => {
  // ===== CONFIG =====
  const CELL = 2.0;
  const MAZE_W = 21;
  const MAZE_H = 21;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_SPEED = 3.2; // units / second
  const MONSTER_COUNT = 8;
  const MONSTER_SPEED = 1.0;
  const SWING_COOLDOWN = 0.6;
  const TRAIL_LENGTH = 14;

  // ===== DOM =====
  const container = document.getElementById('canvas-container');
  const hudHealth = document.getElementById('health');
  const hudMonsters = document.getElementById('monsters');
  const hudFPS = document.getElementById('fps');
  const messageBox = document.getElementById('message');

  // ===== GLOBALS =====
  let yaw = 0, pitch = 0; // mouse look
  const input = { forward:false, back:false, left:false, right:false };
  let pointerLocked = false;

  // ===== THREE SETUP =====
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);
  scene.fog = new THREE.FogExp2(0x0b1220, 0.035);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
  camera.position.set(CELL, PLAYER_HEIGHT, CELL);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  const clock = new THREE.Clock();

  // ===== TEXTURES =====
  const loader = new THREE.TextureLoader();
  const floorTex = loader.load('https://i.imgur.com/yY6tjqm.jpeg'); // floor
  floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
  floorTex.repeat.set(20,20);

  const wallTex = loader.load('https://i.imgur.com/Jd2NPFf.jpeg'); // wall
  wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;

  const monsterTex = loader.load('https://i.imgur.com/8d5VGwN.jpeg');

  // ===== LIGHTS =====
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xfff7ec, 0.9);
  sun.position.set(20, 50, 20);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.left = -50; sun.shadow.camera.right = 50;
  sun.shadow.camera.top = 50; sun.shadow.camera.bottom = -50;
  scene.add(sun);

  // ===== FLOOR =====
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(CELL * MAZE_W * 2, CELL * MAZE_H * 2),
    new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.95 })
  );
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // ===== WORLD STORAGE =====
  let walls = [];    // {mesh, x, z}
  let monsters = []; // Monster instances
  let particles = []; // particle Points

  // ===== MAZE (recursive backtracker) =====
  class Maze {
    constructor(w,h){
      this.w = (w % 2 === 0) ? w+1 : w;
      this.h = (h % 2 === 0) ? h+1 : h;
      this.grid = [];
      for(let z=0; z<this.h; z++){
        this.grid[z] = [];
        for(let x=0; x<this.w; x++){
          this.grid[z][x] = '#';
        }
      }
    }
    generate(){
      const w = this.w, h = this.h;
      const stack = [];
      const startX = 1, startZ = 1;
      this.grid[startZ][startX] = '.';
      stack.push({x:startX,z:startZ});
      const dirs = [{x:0,z:-2},{x:2,z:0},{x:0,z:2},{x:-2,z:0}];
      while(stack.length){
        const cur = stack[stack.length-1];
        const neighbors = [];
        for(const d of dirs){
          const nx = cur.x + d.x, nz = cur.z + d.z;
          if(nx>0 && nz>0 && nx<w-1 && nz<h-1 && this.grid[nz][nx] === '#'){
            neighbors.push({x:nx,z:nz,dir:d});
          }
        }
        if(neighbors.length === 0) { stack.pop(); }
        else {
          const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
          const betweenX = cur.x + pick.dir.x/2;
          const betweenZ = cur.z + pick.dir.z/2;
          this.grid[betweenZ][betweenX] = '.';
          this.grid[pick.z][pick.x] = '.';
          stack.push({x:pick.x,z:pick.z});
        }
      }
      // entrance/exit
      this.grid[1][0] = '.';
      this.grid[this.h-2][this.w-1] = '.';
    }
    buildMeshes() {
      // remove old walls
      walls.forEach(w=>scene.remove(w.mesh));
      walls = [];
      const geom = new THREE.BoxGeometry(CELL, CELL*1.1, CELL);
      const mat = new THREE.MeshStandardMaterial({ map: wallTex, roughness:0.92, metalness:0.02 });
      const offsetX = - (this.w * CELL)/2 + CELL/2;
      const offsetZ = - (this.h * CELL)/2 + CELL/2;
      for(let z=0; z<this.h; z++){
        for(let x=0; x<this.w; x++){
          if(this.grid[z][x] === '#'){
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(offsetX + x*CELL, CELL*0.55, offsetZ + z*CELL);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            walls.push({mesh, x, z});
          }
        }
      }
      return {offsetX, offsetZ};
    }
  }

  const maze = new Maze(MAZE_W, MAZE_H);
  maze.generate();
  const offsets = maze.buildMeshes();

  // ===== PLAYER CLASS =====
  class Player {
    constructor(camera){
      this.camera = camera;
      this.pos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
      this.health = 100;
      this.speed = PLAYER_SPEED;
      this.radius = 0.35;
      this.walkTimer = 0;
      this.canMove = true;
      this.shake = {intensity:0, duration:0};
    }
    setPosition(x,z){
      this.pos.x = x; this.pos.z = z;
      this.camera.position.set(x, PLAYER_HEIGHT, z);
    }
    applyShake(dt){
      if(this.shake.duration > 0){
        this.shake.duration -= dt;
        const s = this.shake.intensity * (this.shake.duration / 0.25);
        camera.position.x += (Math.random()*2-1)*s;
        camera.position.y += (Math.random()*2-1)*s*0.5;
        camera.position.z += (Math.random()*2-1)*s;
      }
    }
    update(dt, input){
      if(!this.canMove) return;
      const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));
      let move = new THREE.Vector3();
      if(input.forward) move.addScaledVector(forward,1);
      if(input.back) move.addScaledVector(forward,-1);
      if(input.left) move.addScaledVector(right,-1);
      if(input.right) move.addScaledVector(right,1);
      if(move.length() > 0.001){
        move.normalize();
        const wanted = this.pos.clone().addScaledVector(move, this.speed * dt);
        if(!checkCollisionCircle(wanted.x, wanted.z, this.radius)){
          this.setPosition(wanted.x, wanted.z);
          this.walkTimer += dt;
          if(this.walkTimer > 0.28){ this.walkTimer = 0; playFootstep(); }
        }
      }
      this.applyShake(dt);
    }
    damage(amount){
      this.health = Math.max(0, this.health - amount);
      hudHealth.innerText = `Health: ${this.health}`;
      this.shake.intensity = 0.12; this.shake.duration = 0.25;
      if(this.health <= 0){
        showMessage("You died! Press R to restart.");
        this.canMove = false;
      }
    }
  }

  // ===== SWORD CLASS =====
  class Sword {
    constructor(player){
      this.player = player;
      const bladeGeo = new THREE.BoxGeometry(0.08, 1.0, 0.12);
      const bladeMat = new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.8, roughness:0.2 });
      this.blade = new THREE.Mesh(bladeGeo, bladeMat);
      this.blade.castShadow = true;
      this.blade.position.set(0.4, -0.6, -1.0);
      this.blade.rotation.x = -0.25;
      const handleGeo = new THREE.BoxGeometry(0.12, 0.25, 0.12);
      const handleMat = new THREE.MeshStandardMaterial({ color:0x553300, roughness:0.8 });
      this.handle = new THREE.Mesh(handleGeo, handleMat);
      this.handle.position.set(0.4, -1.05, -1.0);
      this.group = new THREE.Group();
      this.group.add(this.blade);
      this.group.add(this.handle);
      camera.add(this.group);
      this.group.position.set(0,0,0);
      this.swinging = false;
      this.timer = 0;
      this.cooldown = 0;
      this.trailPositions = [];
      this.trailGeo = new THREE.BufferGeometry();
      this.trailGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(TRAIL_LENGTH*3), 3));
      this.trailMat = new THREE.LineBasicMaterial({ color:0xffd080, transparent:true, opacity:0.9 });
      this.trail = new THREE.Line(this.trailGeo, this.trailMat);
      scene.add(this.trail);
      this._didHit = false;
    }
    startSwing(){
      if(this.cooldown > 0) return false;
      this.swinging = true;
      this.timer = 0.02;
      this._didHit = false;
      playSwing();
      return true;
    }
    update(dt){
      if(this.cooldown > 0) this.cooldown = Math.max(0, this.cooldown - dt);
      if(this.swinging){
        this.timer += dt * 6.0;
        const pr = this.timer;
        const angle = Math.sin(pr) * Math.PI * 0.7;
        this.group.rotation.set(angle - 0.7, 0, 0);
        const worldPos = new THREE.Vector3();
        this.blade.getWorldPosition(worldPos);
        this.trailPositions.unshift(worldPos.clone());
        if(this.trailPositions.length > TRAIL_LENGTH) this.trailPositions.pop();
        this.updateTrail();
        if(pr > Math.PI*0.28 && pr < Math.PI*0.55 && !this._didHit){
          this._didHit = true;
          this.tryHit(worldPos);
        }
        if(this.timer > Math.PI){
          this.swinging = false;
          this._didHit = false;
          this.timer = 0;
          this.cooldown = SWING_COOLDOWN;
        }
      } else {
        // idle sway
        this.group.rotation.x = -0.3 + Math.sin(performance.now() * 0.002) * 0.02;
        if(this.trailPositions.length) { this.trailPositions.shift(); this.updateTrail(); }
      }
    }
    updateTrail(){
      const arr = this.trailGeo.attributes.position.array;
      for(let i=0;i<TRAIL_LENGTH;i++){
        const p = this.trailPositions[i];
        const idx = i*3;
        if(p){ arr[idx]=p.x; arr[idx+1]=p.y; arr[idx+2]=p.z; } else { arr[idx]=arr[idx+1]=arr[idx+2]=0; }
      }
      this.trailGeo.attributes.position.needsUpdate = true;
    }
    tryHit(worldPos){
      const hitRadius = 1.6;
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
      for(let i=monsters.length-1;i>=0;i--){
        const mon = monsters[i];
        const mpos = mon.mesh.position;
        const toMonster = mpos.clone().sub(camera.position);
        const dist = toMonster.length();
        if(dist <= hitRadius){
          toMonster.y = 0; toMonster.normalize();
          const dot = forward.dot(toMonster);
          if(dot > 0.3){
            mon.hit(1 + Math.floor(Math.random()*3));
            playHit();
            spawnHitParticles(mpos.x, mpos.y + 0.5, mpos.z);
            const kb = toMonster.clone().multiplyScalar(-0.9);
            mon.applyKnockback(kb);
            if(mon.hp <= 0){
              scene.remove(mon.mesh);
              monsters.splice(i,1);
              hudMonsters.innerText = `Monsters: ${monsters.length}`;
            }
          }
        }
      }
    }
  }

  // ===== MONSTER CLASS =====
  class Monster {
    constructor(x,z){
      const geo = new THREE.BoxGeometry(CELL*0.35, CELL*0.9, CELL*0.35);
      const mat = new THREE.MeshStandardMaterial({ map: monsterTex, color:0xff6666, roughness:0.85 });
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.castShadow = true;
      this.mesh.position.set(x, 0.45, z);
      scene.add(this.mesh);
      const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color:0xff9933 });
      this.eye = new THREE.Mesh(eyeGeo, eyeMat);
      this.eye.position.set(0, 0.45, 0.26);
      this.mesh.add(this.eye);
      this.hp = 3 + Math.floor(Math.random()*3);
      this.speed = MONSTER_SPEED * (0.9 + Math.random()*0.4);
      this.knockback = new THREE.Vector3();
      this.knockTimer = 0;
    }
    update(dt){
      // bob
      this.mesh.position.y = 0.45 + Math.sin(performance.now()*0.002 + (this.mesh.position.x + this.mesh.position.z)) * 0.06;
      // glow pulse
      const glow = 0.5 + Math.abs(Math.sin(performance.now()*0.003 + this.mesh.position.x)) * 0.6;
      this.eye.scale.set(1,1,1).multiplyScalar(1 + (glow-0.5)*0.15);
      // movement
      const toPlayer = camera.position.clone().sub(this.mesh.position);
      toPlayer.y = 0;
      const dist = toPlayer.length();
      if(this.knockTimer > 0){
        this.mesh.position.addScaledVector(this.knockback, dt);
        this.knockTimer -= dt;
        if(this.knockTimer <= 0) this.knockback.set(0,0,0);
        return;
      }
      if(dist > 1.5){
        toPlayer.normalize();
        const wanted = this.mesh.position.clone().addScaledVector(toPlayer, this.speed * dt);
        if(!checkCollisionCircle(wanted.x, wanted.z, 0.35)) this.mesh.position.copy(wanted);
      } else {
        if(Math.random() < dt * 0.3){
          player.damage(5 + Math.floor(Math.random()*4));
        }
      }
    }
    hit(dmg){ this.hp -= dmg; this.mesh.material.color.setHex(0xff4444); setTimeout(()=>{ this.mesh.material.color.setHex(0xff6666); }, 120); }
    applyKnockback(vec){ this.knockback.copy(vec); this.knockTimer = 0.12 + Math.random()*0.08; }
  }

  // ===== PARTICLES =====
  function spawnHitParticles(x,y,z){
    const count = 18 + Math.floor(Math.random()*12);
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count*3);
    const velocities = [];
    for(let i=0;i<count;i++){
      positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
      velocities.push(new THREE.Vector3((Math.random()*2-1)*1.8, Math.random()*1.6, (Math.random()*2-1)*1.8));
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ size:0.08, color:0xffd0a6, transparent:true });
    const pts = new THREE.Points(geom, mat);
    pts._velocities = velocities;
    pts._life = 0.8 + Math.random()*0.6;
    scene.add(pts);
    particles.push(pts);
  }

  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p._life -= dt;
      const arr = p.geometry.attributes.position.array;
      for(let j=0;j<arr.length/3;j++){
        arr[j*3] += p._velocities[j].x * dt;
        arr[j*3+1] += p._velocities[j].y * dt;
        arr[j*3+2] += p._velocities[j].z * dt;
        p._velocities[j].y -= 3.5 * dt;
        p._velocities[j].multiplyScalar(0.995);
      }
      p.geometry.attributes.position.needsUpdate = true;
      p.material.opacity = Math.max(0, p._life / 1.0);
      if(p._life <= 0){ scene.remove(p); particles.splice(i,1); }
    }
  }

  // ===== COLLISION =====
  function checkCollisionCircle(wx, wz, radius){
    for(const w of walls){
      const mx = w.mesh.position.x, mz = w.mesh.position.z;
      const dx = wx - mx, dz = wz - mz;
      const half = CELL * 0.5 * 0.9;
      const closestX = Math.max(-half, Math.min(half, dx));
      const closestZ = Math.max(-half, Math.min(half, dz));
      const ox = dx - closestX, oz = dz - closestZ;
      const dist2 = ox*ox + oz*oz;
      if(dist2 < radius*radius) return true;
    }
    return false;
  }

  // ===== INPUT & POINTER LOCK =====
  window.addEventListener('keydown', (e) => {
    if(e.code === 'KeyW') input.forward = true;
    if(e.code === 'KeyS') input.back = true;
    if(e.code === 'KeyA') input.left = true;
    if(e.code === 'KeyD') input.right = true;
    if(e.code === 'KeyR') restart();
  });
  window.addEventListener('keyup', (e) => {
    if(e.code === 'KeyW') input.forward = false;
    if(e.code === 'KeyS') input.back = false;
    if(e.code === 'KeyA') input.left = false;
    if(e.code === 'KeyD') input.right = false;
  });

  renderer.domElement.style.cursor = 'pointer';
  renderer.domElement.addEventListener('click', ()=> {
    renderer.domElement.requestPointerLock();
  });
  document.addEventListener('pointerlockchange', ()=> {
    pointerLocked = document.pointerLockElement === renderer.domElement;
    renderer.domElement.style.cursor = pointerLocked ? 'none' : 'pointer';
  });

  window.addEventListener('mousemove', (e)=> {
    if(!pointerLocked) return;
    const sensitivity = 0.0026;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    camera.rotation.set(pitch, yaw, 0);
  });

  // ===== WEBAUDIO (simple tones) =====
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playTone(freq, time, type='sine', gain=0.05){
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type; osc.frequency.value = freq; g.gain.value = gain;
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + time);
    g.gain.setValueAtTime(g.gain.value, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  }
  function playFootstep(){ playTone(120 + Math.random()*30, 0.12, 'sine', 0.028); }
  function playSwing(){ playTone(680 + Math.random()*160, 0.08, 'triangle', 0.08); playTone(300, 0.12, 'sine', 0.02); }
  function playHit(){ playTone(240, 0.06, 'sawtooth', 0.12); playTone(980, 0.12, 'square', 0.04); }

  // ===== PLAYER & SWORD & MONSTERS CREATION =====
  const player = new Player(camera);
  // center start: convert maze cell (1,1) into world coords
  const startWorldX = offsets.offsetX + CELL * 1;
  const startWorldZ = offsets.offsetZ + CELL * 1;
  player.setPosition(startWorldX, startWorldZ);

  const sword = new Sword(player);

  function pickFreeCellWorld() {
    while(true){
      const x = Math.floor(Math.random() * (maze.w - 2)) + 1;
      const z = Math.floor(Math.random() * (maze.h - 2)) + 1;
      if(maze.grid[z][x] === '.'){
        const wx = offsets.offsetX + x*CELL;
        const wz = offsets.offsetZ + z*CELL;
        if(Math.hypot(wx - player.pos.x, wz - player.pos.z) > CELL * 3) return {x:wx, z:wz};
      }
    }
  }

  for(let i=0;i<MONSTER_COUNT;i++){
    const pos = pickFreeCellWorld();
    const m = new Monster(pos.x, pos.z);
    monsters.push(m);
  }
  hudMonsters.innerText = `Monsters: ${monsters.length}`;

  // click to swing
  window.addEventListener('mousedown', (e)=>{
    if(!pointerLocked) return;
    if(e.button === 0) {
      const started = sword.startSwing();
      if(started){ player.shake.intensity = 0.02; player.shake.duration = 0.08; }
    }
  });

  // ===== OPTIONAL: Add some sparse random walls (from the smaller code vibe) =====
  // We'll add a few decorative cubes away from maze area to give variety — non-colliding (pure decoration)
  (function addDecorativeWalls(){
    const decoGeo = new THREE.BoxGeometry(1.6, 1.6, 1.6);
    const decoMat = new THREE.MeshPhongMaterial({ color: 0x6b6b6b });
    for(let i=0;i<18;i++){
      const d = new THREE.Mesh(decoGeo, decoMat);
      const rx = (Math.random()-0.5) * CELL * MAZE_W * 1.2;
      const rz = (Math.random()-0.5) * CELL * MAZE_H * 1.2;
      d.position.set(rx, 0.8, rz);
      d.castShadow = true;
      scene.add(d);
    }
  })();

  // ===== SPAWN / RESTART =====
  function restart(){
    // remove monsters & particles & walls from scene and rebuild maze
    monsters.forEach(m => scene.remove(m.mesh));
    monsters.length = 0;
    particles.forEach(p => scene.remove(p));
    particles.length = 0;
    maze.generate();
    const newOffsets = maze.buildMeshes();
    // reposition player
    player.setPosition(newOffsets.offsetX + CELL, newOffsets.offsetZ + CELL);
    // spawn monsters
    for(let i=0;i<MONSTER_COUNT;i++){
      const pos = pickFreeCellWorld();
      const m = new Monster(pos.x, pos.z);
      monsters.push(m);
    }
    hudMonsters.innerText = `Monsters: ${monsters.length}`;
    player.health = 100;
    hudHealth.innerText = `Health: ${player.health}`;
    player.canMove = true;
    showMessage('Maze regenerated');
  }

  // ===== UTIL: particles updater, HUD, messages =====
  function updateParticles(dt){ /* defined above as closure - but call same function */ }
  // Provide the actual updateParticles function used earlier (re-define to ensure closure)
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p._life -= dt;
      const arr = p.geometry.attributes.position.array;
      for(let j=0;j<arr.length/3;j++){
        arr[j*3] += p._velocities[j].x * dt;
        arr[j*3+1] += p._velocities[j].y * dt;
        arr[j*3+2] += p._velocities[j].z * dt;
        p._velocities[j].y -= 3.5 * dt;
        p._velocities[j].multiplyScalar(0.995);
      }
      p.geometry.attributes.position.needsUpdate = true;
      p.material.opacity = Math.max(0, p._life / 1.0);
      if(p._life <= 0){ scene.remove(p); particles.splice(i,1); }
    }
  }

  function showMessage(txt, t=3000){
    messageBox.innerText = txt; messageBox.style.display = 'block';
    if(t>0) setTimeout(()=> messageBox.style.display='none', t);
  }

  // ===== SIMPLE FPS COUNTER =====
  let frames = 0, accum = 0;

  // ===== MAIN UPDATE & RENDER =====
  function update(dt){
    player.update(dt, input);
    sword.update(dt);
    for(const m of monsters) m.update(dt);
    updateParticles(dt);
    frames++; accum += dt;
    if(accum > 0.6){ hudFPS.innerText = `FPS: ${Math.round(frames/accum)}`; frames=0; accum=0; }
  }
  function render(){ renderer.render(scene, camera); }

  function animate(){
    const dt = Math.min(0.05, clock.getDelta());
    update(dt); render();
    requestAnimationFrame(animate);
  }
  animate();
  showMessage('Click the canvas to lock pointer and play', 3500);

  // ===== NOTE: favicon 404 is harmless =====
  // ===== End of closure =====
})();
</script>
</body>
</html>
