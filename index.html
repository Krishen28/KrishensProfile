<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dungeon Maze — Fast Start</title>
<style>
  html,body{height:100%;margin:0;background:#04050a; color:#fff; font-family:Inter,system-ui,Arial; overflow:hidden;}
  #loading { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; z-index:2000; color:#ddd; }
  #loading.small { background:transparent; pointer-events:none; }
  #hud { position:fixed; left:12px; top:12px; z-index:1500; background:rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px; font-size:13px; }
  #message{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1600;padding:18px 28px;border-radius:12px;background:rgba(0,0,0,0.8);display:none;}
  #attackCooldown {position:fixed; left:50%; bottom:40px; transform:translateX(-50%); width:120px; height:8px; background:rgba(255,255,255,0.06); border-radius:6px; overflow:hidden; z-index:1500;}
  #attackCooldownBar{height:100%; width:0%; background:linear-gradient(90deg,#ff8800,#ffcc66);}
  canvas { display:block; }
</style>
</head>
<body>
<div id="loading"><div><strong>Dungeon Maze</strong><div style="font-size:13px;margin-top:6px">Starting…</div></div></div>
<div id="hud">Health: <span id="health">100</span> — Enemies: <span id="enemies">0</span> — FPS: <span id="fps">0</span></div>
<div id="attackCooldown"><div id="attackCooldownBar"></div></div>
<div id="message"></div>

<!-- Fast, single-file build using non-module three (works without bundling) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
/*
  Fast-start Dungeon Maze
  - Immediate first frame: procedural textures + minimal setup
  - Background: lazy-load remote textures and higher particle/lighting details
  - Optional: uses uploaded local path (see below) if available for later use
*/

const uploadedLocalPath = '/mnt/data/Screenshot 2025-11-24 at 11.14.38 AM.png'; // developer-provided path

// CONFIG - tuned for instant start
const CONFIG = {
  mazeW: 21, mazeH: 21, cell: 2.5,
  playerHeight: 1.7, playerSpeed: 3.2, playerRadius: 0.36,
  monsters: 8, particleCountInitial: 80, particleCountFull: 300,
  shadowSizeLow: 512, shadowSizeHigh: 1024
};

// DOM refs
const loadingEl = document.getElementById('loading');
const hudHealth = document.getElementById('health');
const hudEnemies = document.getElementById('enemies');
const hudFPS = document.getElementById('fps');
const msgBox = document.getElementById('message');
const cooldownBar = document.getElementById('attackCooldownBar');

// Minimal immediate three setup (procedural textures)
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x07080c);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
camera.position.set(CONFIG.cell, CONFIG.playerHeight, CONFIG.cell);

// create renderer and append immediately so user sees something
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// handle resize
window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// --- quick procedural textures so we don't wait on network ---
function createCanvasTexture(drawFn, size=256) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  drawFn(ctx, size);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

const floorTexFast = createCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#10121a'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle = '#14161b';
  for(let y=0;y<s;y+=32) for(let x=0;x<s;x+=32) ctx.fillRect(x+2,y+2,28,28);
});
floorTexFast.repeat = new THREE.Vector2(10,10);

const wallTexFast = createCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#15141a'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle = '#222';
  for(let y=0;y<s;y+=28) for(let x=0;x<s;x+=56) ctx.fillRect(x+(y/28%2?10:0), y, 48, 18);
});

// basic lights (lightweight)
const hemi = new THREE.HemisphereLight(0x666688, 0x20222a, 0.25);
scene.add(hemi);
const sun = new THREE.DirectionalLight(0xffffff, 0.5);
sun.position.set(20, 40, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(CONFIG.shadowSizeLow, CONFIG.shadowSizeLow);
scene.add(sun);

// floor immediate
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshStandardMaterial({ map: floorTexFast, roughness: 1 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// --- Light-weight maze generator (immediate) ---
class Maze {
  constructor(w,h){
    this.w = (w%2? w: w+1);
    this.h = (h%2? h: h+1);
    this.grid = Array(this.h).fill().map(()=>Array(this.w).fill('#'));
  }
  generate() {
    const dirs = [{x:0,z:-2},{x:2,z:0},{x:0,z:2},{x:-2,z:0}];
    const stack = [{x:1,z:1}];
    this.grid[1][1] = '.';
    while(stack.length){
      const cur = stack[stack.length-1];
      const neigh = [];
      for(const d of dirs){
        const nx = cur.x + d.x, nz = cur.z + d.z;
        if(nx>0 && nz>0 && nx<this.w-1 && nz<this.h-1 && this.grid[nz][nx]==='#') neigh.push({x:nx,z:nz,dir:d});
      }
      if(neigh.length===0) stack.pop();
      else {
        const pick = neigh[Math.floor(Math.random()*neigh.length)];
        this.grid[cur.z + pick.dir.z/2][cur.x + pick.dir.x/2] = '.';
        this.grid[pick.z][pick.x] = '.';
        stack.push({x:pick.x,z:pick.z});
      }
    }
    this.grid[1][0] = '.';
    this.grid[this.h-2][this.w-1] = '.';
  }
  buildImmediate(scene) {
    // use single simple material and simple geometry for instant frames
    this.offsetX = - (this.w * CONFIG.cell)/2 + CONFIG.cell/2;
    this.offsetZ = - (this.h * CONFIG.cell)/2 + CONFIG.cell/2;
    const geo = new THREE.BoxGeometry(CONFIG.cell*0.96, CONFIG.cell*1.05, CONFIG.cell*0.96);
    const mat = new THREE.MeshStandardMaterial({ map: wallTexFast, roughness: 1 });
    this.wallMeshes = [];
    for(let z=0; z<this.h; z++){
      for(let x=0; x<this.w; x++){
        if(this.grid[z][x]==='#'){
          const m = new THREE.Mesh(geo, mat);
          m.position.set(this.offsetX + x*CONFIG.cell, (CONFIG.cell*1.05)/2, this.offsetZ + z*CONFIG.cell);
          m.castShadow = true; m.receiveShadow = true;
          scene.add(m);
          this.wallMeshes.push({mesh:m,x,z});
        }
      }
    }
    return { offsetX: this.offsetX, offsetZ: this.offsetZ, walls:this.wallMeshes };
  }
}

// Create instantly visible maze + walls now
const maze = new Maze(CONFIG.mazeW, CONFIG.mazeH);
maze.generate();
const built = maze.buildImmediate(scene);
let walls = built.walls;

// --- player & simple movement (instant) ---
const player = { health: 100, yaw:0, pitch:0, canMove:true, x: built.offsetX + CONFIG.cell, z: built.offsetZ + CONFIG.cell };
camera.position.set(player.x, CONFIG.playerHeight, player.z);

// minimal sword placeholder (visible immediately)
const sword = (function(){
  const g = new THREE.Group();
  const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.12), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness:0.8 }));
  blade.position.set(0.35,-0.5,-0.9);
  const h = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.24,0.12), new THREE.MeshStandardMaterial({ color:0x552200 }));
  h.position.set(0.35,-0.9,-0.9);
  g.add(blade,h);
  g.position.set(0,0,0);
  camera.add(g);
  scene.add(camera);
  return { group:g, swinging:false, timer:0, cooldown:0 };
})();

// simple array of monster placeholders (boxes) so HUD isn't empty — spawn minimal boxes now
let monsters = [];
function spawnMonstersImmediate(count){
  for(let i=0;i<count;i++){
    // pick random free cell quickly
    let tries=0;
    while(tries++ < 80){
      const x = Math.floor(Math.random() * (maze.w - 2)) + 1;
      const z = Math.floor(Math.random() * (maze.h - 2)) + 1;
      if(maze.grid[z][x] === '.') {
        const wx = built.offsetX + x*CONFIG.cell;
        const wz = built.offsetZ + z*CONFIG.cell;
        if(Math.hypot(wx - player.x, wz - player.z) > CONFIG.cell*3) {
          const b = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cell*0.36, CONFIG.cell*0.9, CONFIG.cell*0.36), new THREE.MeshStandardMaterial({ color:0xff4444 }));
          b.position.set(wx, 0.45, wz);
          b.castShadow = true;
          scene.add(b);
          monsters.push({ mesh:b, hp:3 });
          break;
        }
      }
    }
  }
  hudEnemies.textContent = monsters.length;
}
spawnMonstersImmediate(CONFIG.monsters);

// INPUT (instant)
const input = { w:false,a:false,s:false,d:false, pointerLocked:false };
window.addEventListener('keydown', e => {
  if(e.code==='KeyW') input.w=true;
  if(e.code==='KeyS') input.s=true;
  if(e.code==='KeyA') input.a=true;
  if(e.code==='KeyD') input.d=true;
  if(e.code==='KeyR') location.reload();
});
window.addEventListener('keyup', e => {
  if(e.code==='KeyW') input.w=false;
  if(e.code==='KeyS') input.s=false;
  if(e.code==='KeyA') input.a=false;
  if(e.code==='KeyD') input.d=false;
});

// pointer lock on click
renderer.domElement.addEventListener('click', ()=> {
  renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', ()=> {
  input.pointerLocked = document.pointerLockElement === renderer.domElement;
});

// immediate mouse look (if pointer locked)
window.addEventListener('mousemove', e => {
  if(!input.pointerLocked) return;
  const sens = 0.0024;
  player.yaw -= e.movementX * sens;
  player.pitch -= e.movementY * sens;
  player.pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, player.pitch));
  camera.rotation.set(player.pitch, player.yaw, 0);
});

// movement tick - minimal collision naively using walls bounding boxes
function simpleMove(dt){
  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));
  const move = new THREE.Vector3();
  if(input.w) move.addScaledVector(forward,1);
  if(input.s) move.addScaledVector(forward,-1);
  if(input.a) move.addScaledVector(right,-1);
  if(input.d) move.addScaledVector(right,1);
  if(move.lengthSq()>0.0001){
    move.normalize();
    const destX = camera.position.x + move.x * CONFIG.playerSpeed * dt;
    const destZ = camera.position.z + move.z * CONFIG.playerSpeed * dt;
    // cheap collision: reject if too close to any wall center
    let blocked = false;
    const r = CONFIG.playerRadius;
    for(const w of walls){
      const dx = destX - w.mesh.position.x, dz = destZ - w.mesh.position.z;
      const half = CONFIG.cell*0.5*0.9;
      const closestX = Math.max(-half, Math.min(half, dx));
      const closestZ = Math.max(-half, Math.min(half, dz));
      const ox = dx - closestX, oz = dz - closestZ;
      if(ox*ox + oz*oz < r*r){ blocked = true; break; }
    }
    if(!blocked){
      camera.position.x = destX;
      camera.position.z = destZ;
    }
  }
}

// particle system (simple initial particles)
let particles = [];
function spawnParticle(x,y,z){
  const p = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({ color:0x66aaff, size:0.06, transparent:true, opacity:0.6 }));
  const arr = new Float32Array([x,y,z]);
  p.geometry.setAttribute('position', new THREE.BufferAttribute(arr,3));
  p._life = 1.0;
  scene.add(p);
  particles.push(p);
}

// --- main loop (immediate) ---
const clock = new THREE.Clock();
let frameCount=0, fpsAccum=0;
function renderFrame(){
  const dt = Math.min(clock.getDelta(), 0.06);
  // movement
  simpleMove(dt);

  // sword cooldown decrement quickly
  if(sword.cooldown > 0) sword.cooldown = Math.max(0, sword.cooldown - dt);
  // particles fade
  for(let i = particles.length-1; i>=0; i--){
    const p = particles[i];
    p._life -= dt;
    p.material.opacity = Math.max(0, p._life);
    if(p._life <= 0){ scene.remove(p); particles.splice(i,1); }
  }

  // simple monsters idle move a little (so scene feels alive)
  for(const m of monsters){
    m.mesh.position.x += (Math.random()-0.5) * dt * 0.06;
    m.mesh.position.z += (Math.random()-0.5) * dt * 0.06;
  }

  renderer.render(scene, camera);

  // FPS update
  frameCount++; fpsAccum += dt;
  if(fpsAccum > 0.5){ hudFPS.textContent = Math.round(frameCount / fpsAccum); frameCount=0; fpsAccum=0; }

  requestAnimationFrame(renderFrame);
}
requestAnimationFrame(renderFrame);

// === BACKGROUND: after initial frame, load better assets and features ===
function backgroundLoad() {
  // 1) Improve shadows resolution and light detail
  sun.shadow.mapSize.set(CONFIG.shadowSizeHigh, CONFIG.shadowSizeHigh);

  // 2) Load nicer remote textures but only after first frame (non-blocking)
  const tl = new THREE.TextureLoader();
  tl.load(
    'https://i.imgur.com/yY6tjqm.jpeg', tex => { floor.material.map = tex; floor.material.needsUpdate = true; tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(20,20); },
    undefined,
    () => { /* ignore load errors, keep fast canvas texture */ }
  );
  tl.load(
    'https://i.imgur.com/Jd2NPFf.jpeg', tex => {
      // Replace wall material smoothly: clone old meshes material to keep GPU stable
      walls.forEach(w => { w.mesh.material = new THREE.MeshStandardMaterial({ map:tex, roughness:0.9 }); });
      tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
    }, undefined, ()=>{}
  );

  // 3) Add more atmospheric particles (gradual)
  setTimeout(()=> {
    for(let i=0;i<CONFIG.particleCountFull - CONFIG.particleCountInitial; i++){
      const x = (Math.random() - 0.5) * 180;
      const y = Math.random() * 3;
      const z = (Math.random() - 0.5) * 180;
      spawnParticle(x,y,z);
    }
  }, 600);

  // 4) Replace monster boxes with richer models (simple swap)
  setTimeout(()=> {
    monsters.forEach(mon => {
      // create a slightly better mesh and swap
      const newMesh = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cell*0.42, CONFIG.cell*0.95, CONFIG.cell*0.42),
        new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness:0.8, metalness:0.1 }));
      newMesh.position.copy(mon.mesh.position);
      scene.remove(mon.mesh);
      scene.add(newMesh);
      mon.mesh = newMesh;
    });
  }, 700);

  // 5) Optionally use uploaded local path (if your environment serves it)
  //    We just attempt to load it as an image and set it to gem or decoration if it succeeds.
  const img = new Image();
  img.onload = () => {
    // we won't crash if it fails — this is optional
    const tex = new THREE.CanvasTexture(img);
    // put as emissive decal on some random wall to show the image
    if(walls.length > 0){
      const target = walls[Math.floor(Math.random()*walls.length)].mesh;
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cell*0.6, CONFIG.cell*0.6), new THREE.MeshBasicMaterial({ map:tex, transparent:true }));
      plane.position.set(0, CONFIG.cell*0.4, CONFIG.cell*0.52);
      target.add(plane);
    }
  };
  img.onerror = ()=>{/* ignore */};
  img.src = uploadedLocalPath;

  // 6) Hide loading overlay now — we waited a tiny bit (keeps first frame)
  setTimeout(()=> {
    loadingEl.classList.add('small');
    // fully hide after short fade (we just remove display)
    setTimeout(()=> loadingEl.style.display='none', 300);
  }, 120);

  // 7) enable some more gameplay logic (attack handling, cleanup) — simple example:
  window.addEventListener('mousedown', (e) => {
    if(e.button!==0) return;
    if(sword.cooldown > 0) return;
    // create fast visible trail and small hit test on monsters
    sword.cooldown = 0.45;
    // small particle burst in front of player
    const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
    const hitX = camera.position.x + forward.x * 1.2;
    const hitZ = camera.position.z + forward.z * 1.2;
    spawnParticle(hitX, camera.position.y - 0.6, hitZ);
    // simple check: kill nearest monster within range
    for(let i=monsters.length-1;i>=0;i--){
      const m = monsters[i];
      const d = Math.hypot(m.mesh.position.x - camera.position.x, m.mesh.position.z - camera.position.z);
      if(d < 2.0){ scene.remove(m.mesh); monsters.splice(i,1); hudEnemies.textContent = monsters.length; break; }
    }
  });
}

// schedule background load (not blocking)
setTimeout(backgroundLoad, 80);

// Utility: show message
function showMessage(text, time=3000){
  msgBox.style.display='block'; msgBox.innerHTML = text;
  if(time>0) setTimeout(()=> msgBox.style.display='none', time);
}

// Quick explanation available to user
console.log("Fast-start Dungeon Maze initialized. Background assets are loading asynchronously.");

// show a brief message then hide
showMessage('Click canvas and move. Heavy assets load in the background.', 2400);
</script>
</body>
</html>
